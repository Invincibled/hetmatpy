



<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
      
      
      
        <meta name="lang:clipboard.copy" content="Copy to clipboard">
      
        <meta name="lang:clipboard.copied" content="Copied to clipboard">
      
        <meta name="lang:search.language" content="en">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="No matching documents">
      
        <meta name="lang:search.result.one" content="1 matching document">
      
        <meta name="lang:search.result.other" content="# matching documents">
      
        <meta name="lang:search.tokenizer" content="[\s\-]+">
      
      <link rel="shortcut icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-4.6.3">
    
    
      
        <title>Degree Weight - hetmatpy</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/application.adb8469c.css">
      
        <link rel="stylesheet" href="../../../assets/stylesheets/application-palette.a8b3c06d.css">
      
      
        
        
        <meta name="theme-color" content="#4caf50">
      
    
    
      <script src="../../../assets/javascripts/modernizr.86422ebf.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../../../assets/fonts/material-icons.css">
    
    
    
      
    
    
  </head>
  
    
    
    <body dir="ltr" data-md-color-primary="green" data-md-color-accent="lightgreen">
  
    <svg class="md-svg">
      <defs>
        
        
          <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="__github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg>
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#module-hetmatpydegree_weight" tabindex="0" class="md-skip">
        Skip to content
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../../.." title="hetmatpy" aria-label="hetmatpy" class="md-header-nav__button md-logo">
          
            <i class="md-icon"></i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              hetmatpy
            </span>
            <span class="md-header-nav__topic">
              
                Degree Weight
              
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" aria-label="search" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            


  

<a href="https://github.com/hetio/hetmatpy/" title="Go to repository" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    hetmatpy
  </div>
</a>
          </div>
        </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main" role="main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="../../.." title="hetmatpy" class="md-nav__button md-logo">
      
        <i class="md-icon"></i>
      
    </a>
    hetmatpy
  </label>
  
    <div class="md-nav__source">
      


  

<a href="https://github.com/hetio/hetmatpy/" title="Go to repository" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    hetmatpy
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../../.." title="Home" class="md-nav__link">
      Home
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../../LICENSE/" title="License" class="md-nav__link">
      License
    </a>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3" checked>
    
    <label class="md-nav__link" for="nav-3">
      Reference
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        Reference
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3-1" type="checkbox" id="nav-3-1" checked>
    
    <label class="md-nav__link" for="nav-3-1">
      Hetmatpy
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-3-1">
        Hetmatpy
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../degree_group/" title="Degree Group" class="md-nav__link">
      Degree Group
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        Degree Weight
      </label>
    
    <a href="./" title="Degree Weight" class="md-nav__link md-nav__link--active">
      Degree Weight
    </a>
    
      
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">Table of contents</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#functions" class="md-nav__link">
    Functions
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#categorize" class="md-nav__link">
    categorize
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#parameters" class="md-nav__link">
    Parameters
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#returns" class="md-nav__link">
    Returns
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#default_dwwc_method" class="md-nav__link">
    default_dwwc_method
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dwpc" class="md-nav__link">
    dwpc
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#parameters_1" class="md-nav__link">
    Parameters
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#returns_1" class="md-nav__link">
    Returns
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#dwwc" class="md-nav__link">
    dwwc
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#parameters_2" class="md-nav__link">
    Parameters
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#dwwc_chain" class="md-nav__link">
    dwwc_chain
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dwwc_recursive" class="md-nav__link">
    dwwc_recursive
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dwwc_sequential" class="md-nav__link">
    dwwc_sequential
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#parameters_3" class="md-nav__link">
    Parameters
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#get_all_segments" class="md-nav__link">
    get_all_segments
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#parameters_4" class="md-nav__link">
    Parameters
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#returns_2" class="md-nav__link">
    Returns
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#example" class="md-nav__link">
    Example
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#get_segments" class="md-nav__link">
    get_segments
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#parameters_5" class="md-nav__link">
    Parameters
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#returns_3" class="md-nav__link">
    Returns
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#examples" class="md-nav__link">
    Examples
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#order_segments" class="md-nav__link">
    order_segments
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#parameters_6" class="md-nav__link">
    Parameters
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#returns_4" class="md-nav__link">
    Returns
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#remove_diag" class="md-nav__link">
    remove_diag
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../diffusion/" title="Diffusion" class="md-nav__link">
      Diffusion
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../" title="Index" class="md-nav__link">
      Index
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../matrix/" title="Matrix" class="md-nav__link">
      Matrix
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../pipeline/" title="Pipeline" class="md-nav__link">
      Pipeline
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../testing/" title="Testing" class="md-nav__link">
      Testing
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../xarray/" title="Xarray" class="md-nav__link">
      Xarray
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3-1-9" type="checkbox" id="nav-3-1-9">
    
    <label class="md-nav__link" for="nav-3-1-9">
      Hetmat
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="3">
      <label class="md-nav__title" for="nav-3-1-9">
        Hetmat
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../hetmat/archive/" title="Archive" class="md-nav__link">
      Archive
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../hetmat/caching/" title="Caching" class="md-nav__link">
      Caching
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../hetmat/" title="Index" class="md-nav__link">
      Index
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
      </ul>
    </nav>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">Table of contents</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#functions" class="md-nav__link">
    Functions
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#categorize" class="md-nav__link">
    categorize
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#parameters" class="md-nav__link">
    Parameters
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#returns" class="md-nav__link">
    Returns
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#default_dwwc_method" class="md-nav__link">
    default_dwwc_method
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dwpc" class="md-nav__link">
    dwpc
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#parameters_1" class="md-nav__link">
    Parameters
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#returns_1" class="md-nav__link">
    Returns
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#dwwc" class="md-nav__link">
    dwwc
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#parameters_2" class="md-nav__link">
    Parameters
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#dwwc_chain" class="md-nav__link">
    dwwc_chain
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dwwc_recursive" class="md-nav__link">
    dwwc_recursive
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dwwc_sequential" class="md-nav__link">
    dwwc_sequential
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#parameters_3" class="md-nav__link">
    Parameters
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#get_all_segments" class="md-nav__link">
    get_all_segments
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#parameters_4" class="md-nav__link">
    Parameters
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#returns_2" class="md-nav__link">
    Returns
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#example" class="md-nav__link">
    Example
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#get_segments" class="md-nav__link">
    get_segments
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#parameters_5" class="md-nav__link">
    Parameters
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#returns_3" class="md-nav__link">
    Returns
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#examples" class="md-nav__link">
    Examples
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#order_segments" class="md-nav__link">
    order_segments
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#parameters_6" class="md-nav__link">
    Parameters
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#returns_4" class="md-nav__link">
    Returns
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#remove_diag" class="md-nav__link">
    remove_diag
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/hetio/hetmatpy/edit/master/reference/hetmatpy/degree_weight.md" title="Edit this page" class="md-icon md-content__icon">&#xE3C9;</a>
                
                
                <h1 id="module-hetmatpydegree_weight">Module hetmatpy.degree_weight</h1>
<details class="example"><summary>View Source</summary><div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="nn">collections</span>

<span class="kn">import</span> <span class="nn">copy</span>

<span class="kn">import</span> <span class="nn">functools</span>

<span class="kn">import</span> <span class="nn">itertools</span>

<span class="kn">import</span> <span class="nn">logging</span>

<span class="kn">import</span> <span class="nn">numpy</span>

<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">sparse</span>

<span class="kn">from</span> <span class="nn">hetnetpy.matrix</span> <span class="kn">import</span> <span class="p">(</span>

    <span class="n">sparsify_or_densify</span><span class="p">,</span>

<span class="p">)</span>

<span class="kn">import</span> <span class="nn">hetmatpy.hetmat</span>

<span class="kn">from</span> <span class="nn">hetmatpy.hetmat.caching</span> <span class="kn">import</span> <span class="n">path_count_cache</span>

<span class="kn">import</span> <span class="nn">hetmatpy.matrix</span>

<span class="k">def</span> <span class="nf">_category_to_function</span><span class="p">(</span><span class="n">category</span><span class="p">,</span> <span class="n">dwwc_method</span><span class="p">):</span>

    <span class="n">function_dictionary</span> <span class="o">=</span> <span class="p">{</span>

        <span class="s1">&#39;no_repeats&#39;</span><span class="p">:</span> <span class="n">dwwc_method</span><span class="p">,</span>

        <span class="s1">&#39;disjoint&#39;</span><span class="p">:</span> <span class="n">_dwpc_disjoint</span><span class="p">,</span>

        <span class="s1">&#39;disjoint_groups&#39;</span><span class="p">:</span> <span class="n">_dwpc_disjoint</span><span class="p">,</span>

        <span class="s1">&#39;short_repeat&#39;</span><span class="p">:</span> <span class="n">_dwpc_short_repeat</span><span class="p">,</span>

        <span class="s1">&#39;four_repeat&#39;</span><span class="p">:</span> <span class="n">_dwpc_baba</span><span class="p">,</span>

        <span class="s1">&#39;long_repeat&#39;</span><span class="p">:</span> <span class="n">_dwpc_general_case</span><span class="p">,</span>

        <span class="s1">&#39;BAAB&#39;</span><span class="p">:</span> <span class="n">_dwpc_baab</span><span class="p">,</span>

        <span class="s1">&#39;BABA&#39;</span><span class="p">:</span> <span class="n">_dwpc_baba</span><span class="p">,</span>

        <span class="s1">&#39;repeat_around&#39;</span><span class="p">:</span> <span class="n">_dwpc_repeat_around</span><span class="p">,</span>

        <span class="s1">&#39;interior_complete_group&#39;</span><span class="p">:</span> <span class="n">_dwpc_baba</span><span class="p">,</span>

        <span class="s1">&#39;other&#39;</span><span class="p">:</span> <span class="n">_dwpc_general_case</span><span class="p">,</span>

    <span class="p">}</span>

    <span class="k">return</span> <span class="n">function_dictionary</span><span class="p">[</span><span class="n">category</span><span class="p">]</span>

<span class="nd">@path_count_cache</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="s1">&#39;dwpc&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">dwpc</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">approx_ok</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>

         <span class="kp">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">dwwc_method</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    A unified function to compute the degree-weighted path count.</span>

<span class="sd">    This function will call get_segments, then the appropriate</span>

<span class="sd">    specialized (or generalized) DWPC function.</span>

<span class="sd">    Parameters</span>

<span class="sd">    ----------</span>

<span class="sd">    graph : hetnetpy.hetnet.Graph</span>

<span class="sd">    metapath : hetnetpy.hetnet.MetaPath</span>

<span class="sd">    damping : float</span>

<span class="sd">    dense_threshold : float (0 &lt;= dense_threshold &lt;= 1)</span>

<span class="sd">        sets the density threshold above which a sparse matrix will be</span>

<span class="sd">        converted to a dense automatically.</span>

<span class="sd">    approx_ok : bool</span>

<span class="sd">        if True, uses an approximation to DWPC. If False, dwpc will call</span>

<span class="sd">        _dwpc_general_case and give a warning on metapaths which are</span>

<span class="sd">        categorized &#39;other&#39; and &#39;long_repeat&#39;..</span>

<span class="sd">    dtype : dtype object</span>

<span class="sd">        numpy.float32 or numpy.float64. At present, numpy.float16 fails when</span>

<span class="sd">        using sparse matrices, due to a bug in scipy.sparse</span>

<span class="sd">    dwwc_method : function</span>

<span class="sd">        dwwc method to use for computing DWWCs. If set to None, use</span>

<span class="sd">        module-level default (default_dwwc_method).</span>

<span class="sd">    Returns</span>

<span class="sd">    -------</span>

<span class="sd">    numpy.ndarray</span>

<span class="sd">        row labels</span>

<span class="sd">    numpy.ndarray</span>

<span class="sd">        column labels</span>

<span class="sd">    numpy.ndarray or scipy.sparse.csc_matrix</span>

<span class="sd">        the DWPC matrix</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">category</span> <span class="o">=</span> <span class="n">categorize</span><span class="p">(</span><span class="n">metapath</span><span class="p">)</span>

    <span class="n">dwpc_function</span> <span class="o">=</span> <span class="n">_category_to_function</span><span class="p">(</span><span class="n">category</span><span class="p">,</span> <span class="n">dwwc_method</span><span class="o">=</span><span class="n">dwwc_method</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">category</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;long_repeat&#39;</span><span class="p">,</span> <span class="s1">&#39;other&#39;</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">approx_ok</span><span class="p">:</span>

            <span class="n">dwpc_function</span> <span class="o">=</span> <span class="n">_dwpc_approx</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Metapath </span><span class="si">{</span><span class="n">metapath</span><span class="si">}</span><span class="s2"> will use _dwpc_general_case, &quot;</span>

                            <span class="s2">&quot;which can require very long computations.&quot;</span><span class="p">)</span>

    <span class="n">row_names</span><span class="p">,</span> <span class="n">col_names</span><span class="p">,</span> <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="n">dwpc_function</span><span class="p">(</span>

        <span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">,</span> <span class="n">damping</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span>

        <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">row_names</span><span class="p">,</span> <span class="n">col_names</span><span class="p">,</span> <span class="n">dwpc_matrix</span>

<span class="nd">@path_count_cache</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="s1">&#39;dwwc&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">dwwc</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">dwwc_method</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Compute the degree-weighted walk count (DWWC) in which nodes can be</span>

<span class="sd">    repeated within a path.</span>

<span class="sd">    Parameters</span>

<span class="sd">    ----------</span>

<span class="sd">    graph : hetnetpy.hetnet.Graph</span>

<span class="sd">    metapath : hetnetpy.hetnet.MetaPath</span>

<span class="sd">    damping : float</span>

<span class="sd">    dense_threshold : float (0 &lt;= dense_threshold &lt;= 1)</span>

<span class="sd">        sets the density threshold at which a sparse matrix will be</span>

<span class="sd">        converted to a dense automatically.</span>

<span class="sd">    dtype : dtype object</span>

<span class="sd">    dwwc_method : function</span>

<span class="sd">        dwwc method to use for computing DWWCs. If set to None, use</span>

<span class="sd">        module-level default (default_dwwc_method).</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">dwwc_method</span><span class="p">(</span>

        <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span>

        <span class="n">metapath</span><span class="o">=</span><span class="n">metapath</span><span class="p">,</span>

        <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span>

        <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span>

        <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">,</span>

    <span class="p">)</span>

<span class="k">def</span> <span class="nf">dwwc_sequential</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Compute the degree-weighted walk count (DWWC) in which nodes can be</span>

<span class="sd">    repeated within a path.</span>

<span class="sd">    Parameters</span>

<span class="sd">    ----------</span>

<span class="sd">    graph : hetnetpy.hetnet.Graph</span>

<span class="sd">    metapath : hetnetpy.hetnet.MetaPath</span>

<span class="sd">    damping : float</span>

<span class="sd">    dense_threshold : float (0 &lt;= dense_threshold &lt;= 1)</span>

<span class="sd">        sets the density threshold at which a sparse matrix will be</span>

<span class="sd">        converted to a dense automatically.</span>

<span class="sd">    dtype : dtype object</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dwwc_matrix</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">row_names</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">for</span> <span class="n">metaedge</span> <span class="ow">in</span> <span class="n">metapath</span><span class="p">:</span>

        <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">adj_mat</span> <span class="o">=</span> <span class="n">hetmatpy</span><span class="o">.</span><span class="kp">matrix</span><span class="o">.</span><span class="n">metaedge_to_adjacency_matrix</span><span class="p">(</span>

            <span class="n">graph</span><span class="p">,</span> <span class="n">metaedge</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

        <span class="n">adj_mat</span> <span class="o">=</span> <span class="n">_degree_weight</span><span class="p">(</span><span class="n">adj_mat</span><span class="p">,</span> <span class="n">damping</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dwwc_matrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">row_names</span> <span class="o">=</span> <span class="n">rows</span>

            <span class="n">dwwc_matrix</span> <span class="o">=</span> <span class="n">adj_mat</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="n">dwwc_matrix</span> <span class="o">=</span> <span class="n">dwwc_matrix</span> <span class="o">@</span> <span class="n">adj_mat</span>

            <span class="n">dwwc_matrix</span> <span class="o">=</span> <span class="n">sparsify_or_densify</span><span class="p">(</span><span class="n">dwwc_matrix</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">row_names</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">dwwc_matrix</span>

<span class="k">def</span> <span class="nf">dwwc_recursive</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Recursive DWWC implementation to take better advantage of caching.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">adj_mat</span> <span class="o">=</span> <span class="n">hetmatpy</span><span class="o">.</span><span class="kp">matrix</span><span class="o">.</span><span class="n">metaedge_to_adjacency_matrix</span><span class="p">(</span>

        <span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

    <span class="n">adj_mat</span> <span class="o">=</span> <span class="n">_degree_weight</span><span class="p">(</span><span class="n">adj_mat</span><span class="p">,</span> <span class="n">damping</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">metapath</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">dwwc_next</span> <span class="o">=</span> <span class="n">dwwc</span><span class="p">(</span>

            <span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span>

            <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">,</span> <span class="n">dwwc_method</span><span class="o">=</span><span class="n">dwwc_recursive</span><span class="p">)</span>

        <span class="n">dwwc_matrix</span> <span class="o">=</span> <span class="n">adj_mat</span> <span class="o">@</span> <span class="n">dwwc_next</span>

    <span class="k">else</span><span class="p">:</span>

        <span class="n">dwwc_matrix</span> <span class="o">=</span> <span class="n">adj_mat</span>

    <span class="n">dwwc_matrix</span> <span class="o">=</span> <span class="n">sparsify_or_densify</span><span class="p">(</span><span class="n">dwwc_matrix</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">dwwc_matrix</span>

<span class="k">def</span> <span class="nf">_multi_dot</span><span class="p">(</span><span class="n">metapath</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">damping</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="p">,</span> <span class="kp">dtype</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Perform matrix multiplication with the given order. Modified from</span>

<span class="sd">    numpy.linalg.linalg._multi_dot (https://git.io/vh31f) which is released</span>

<span class="sd">    under a 3-Clause BSD License (https://git.io/vhCDC).</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">adj_mat</span> <span class="o">=</span> <span class="n">hetmatpy</span><span class="o">.</span><span class="kp">matrix</span><span class="o">.</span><span class="n">metaedge_to_adjacency_matrix</span><span class="p">(</span>

            <span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

        <span class="n">adj_mat</span> <span class="o">=</span> <span class="n">_degree_weight</span><span class="p">(</span><span class="n">adj_mat</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">adj_mat</span>

    <span class="k">return</span> <span class="n">_multi_dot</span><span class="p">(</span><span class="n">metapath</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">order</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">graph</span><span class="p">,</span> <span class="n">damping</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="p">,</span> <span class="kp">dtype</span><span class="p">)</span> \

        <span class="o">@</span> <span class="n">_multi_dot</span><span class="p">(</span><span class="n">metapath</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">order</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">damping</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="p">,</span> <span class="kp">dtype</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_dimensions_to_ordering</span><span class="p">(</span><span class="n">dimensions</span><span class="p">):</span>

    <span class="c1"># Find optimal matrix chain ordering. See https://git.io/vh38o</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="n">m</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="kp">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="kp">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>

    <span class="n">ordering</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="kp">empty</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="kp">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">l_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">l_</span><span class="p">):</span>

            <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">l_</span>

            <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="kp">inf</span>

            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>

                <span class="n">q</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">m</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">dimensions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">dimensions</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">dimensions</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">q</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]:</span>

                    <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span>

                    <span class="n">ordering</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>

    <span class="k">return</span> <span class="n">ordering</span>

<span class="k">def</span> <span class="nf">dwwc_chain</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Uses optimal matrix chain multiplication as in numpy.multi_dot, but allows</span>

<span class="sd">    for sparse matrices. Uses ordering modified from numpy.linalg.linalg._multi_dot</span>

<span class="sd">    (https://git.io/vh31f) which is released under a 3-Clause BSD License</span>

<span class="sd">    (https://git.io/vhCDC).</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">metapath</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">metagraph</span><span class="o">.</span><span class="n">get_metapath</span><span class="p">(</span><span class="n">metapath</span><span class="p">)</span>

    <span class="n">array_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">graph</span><span class="o">.</span><span class="n">count_nodes</span><span class="p">(</span><span class="n">mn</span><span class="p">)</span> <span class="k">for</span> <span class="n">mn</span> <span class="ow">in</span> <span class="n">metapath</span><span class="o">.</span><span class="n">get_nodes</span><span class="p">()]</span>

    <span class="n">row_ids</span> <span class="o">=</span> <span class="n">hetmatpy</span><span class="o">.</span><span class="kp">matrix</span><span class="o">.</span><span class="n">get_node_identifiers</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="o">.</span><span class="kp">source</span><span class="p">())</span>

    <span class="n">columns_ids</span> <span class="o">=</span> <span class="n">hetmatpy</span><span class="o">.</span><span class="kp">matrix</span><span class="o">.</span><span class="n">get_node_identifiers</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="o">.</span><span class="n">target</span><span class="p">())</span>

    <span class="n">ordering</span> <span class="o">=</span> <span class="n">_dimensions_to_ordering</span><span class="p">(</span><span class="n">array_dims</span><span class="p">)</span>

    <span class="n">dwwc_matrix</span> <span class="o">=</span> <span class="n">_multi_dot</span><span class="p">(</span><span class="n">metapath</span><span class="p">,</span> <span class="n">ordering</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">metapath</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">damping</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="p">,</span> <span class="kp">dtype</span><span class="p">)</span>

    <span class="n">dwwc_matrix</span> <span class="o">=</span> <span class="n">sparsify_or_densify</span><span class="p">(</span><span class="n">dwwc_matrix</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">row_ids</span><span class="p">,</span> <span class="n">columns_ids</span><span class="p">,</span> <span class="n">dwwc_matrix</span>

<span class="k">def</span> <span class="nf">categorize</span><span class="p">(</span><span class="n">metapath</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Returns the classification of a given metapath as one of</span>

<span class="sd">    a set of metapath types which we approach differently.</span>

<span class="sd">    Parameters</span>

<span class="sd">    ----------</span>

<span class="sd">    metapath : hetnetpy.hetnet.MetaPath</span>

<span class="sd">    Returns</span>

<span class="sd">    -------</span>

<span class="sd">    classification : string</span>

<span class="sd">        One of [&#39;no_repeats&#39;, &#39;disjoint&#39;, &#39;short_repeat&#39;,</span>

<span class="sd">                &#39;long_repeat&#39;, &#39;BAAB&#39;, &#39;BABA&#39;, &#39;repeat_around&#39;,</span>

<span class="sd">                 &#39;interior_complete_group&#39;, &#39;disjoint_groups&#39;, &#39;other&#39;]</span>

<span class="sd">    Examples</span>

<span class="sd">    --------</span>

<span class="sd">    GbCtDlA -&gt; &#39;no_repeats&#39;</span>

<span class="sd">    GiGiG   -&gt; &#39;short_repeat&#39;</span>

<span class="sd">    GiGiGcG -&gt; &#39;four_repeat&#39;</span>

<span class="sd">    GiGcGiGiG -&gt; &#39;long_repeat&#39;</span>

<span class="sd">    GiGbCrC -&gt; &#39;disjoint&#39;</span>

<span class="sd">    GbCbGbC -&gt; &#39;BABA&#39;</span>

<span class="sd">    GbCrCbG -&gt; &#39;BAAB&#39;</span>

<span class="sd">    DaGiGbCrC -&gt; &#39;disjoint&#39;</span>

<span class="sd">    GiGaDpCrC -&gt; &#39;disjoint&#39;</span>

<span class="sd">    GiGbCrCpDrD -&gt; &#39;disjoint&#39;</span>

<span class="sd">    GbCpDaGbCpD -&gt; &#39;other&#39;</span>

<span class="sd">    GbCrCrCrCrCbG -&gt; &#39;other&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">metanodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">metapath</span><span class="o">.</span><span class="n">get_nodes</span><span class="p">())</span>

    <span class="n">freq</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">(</span><span class="n">metanodes</span><span class="p">)</span>

    <span class="n">repeated</span> <span class="o">=</span> <span class="p">{</span><span class="n">metanode</span> <span class="k">for</span> <span class="n">metanode</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">freq</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">}</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">repeated</span><span class="p">:</span>

        <span class="k">return</span> <span class="s1">&#39;no_repeats&#39;</span>

    <span class="n">repeats_only</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">metanodes</span> <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">repeated</span><span class="p">]</span>

    <span class="c1"># Group neighbors if they are the same</span>

    <span class="n">grouped</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">repeats_only</span><span class="p">)]</span>

    <span class="c1"># Handle multiple disjoint repeats, any number, ie. AA,BB,CC,DD,...</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">grouped</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">repeated</span><span class="p">):</span>

        <span class="c1"># Identify if there is only one metanode</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">repeated</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

            <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">freq</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>

                <span class="k">return</span> <span class="s1">&#39;short_repeat&#39;</span>

            <span class="k">elif</span> <span class="nb">max</span><span class="p">(</span><span class="n">freq</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>

                <span class="k">return</span> <span class="s1">&#39;four_repeat&#39;</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="k">return</span> <span class="s1">&#39;long_repeat&#39;</span>

        <span class="k">return</span> <span class="s1">&#39;disjoint&#39;</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">repeats_only</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span>

    <span class="c1"># Categorize the reformatted metapath</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">repeats_only</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>

        <span class="k">if</span> <span class="n">repeats_only</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">repeats_only</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>

            <span class="k">assert</span> <span class="n">repeats_only</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">repeats_only</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

            <span class="k">return</span> <span class="s1">&#39;BAAB&#39;</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="k">assert</span> <span class="p">(</span><span class="n">repeats_only</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">repeats_only</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">and</span>

                    <span class="n">repeats_only</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">repeats_only</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

            <span class="k">return</span> <span class="s1">&#39;BABA&#39;</span>

    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">repeats_only</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span> <span class="ow">and</span> <span class="nb">max</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">grouped</span><span class="p">))</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>

        <span class="k">if</span> <span class="n">repeats_only</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">repeats_only</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>

            <span class="k">return</span> <span class="s1">&#39;BAAB&#39;</span>

    <span class="k">elif</span> <span class="n">repeats_only</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">repeats_only</span><span class="p">))</span> <span class="ow">and</span> \

            <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">repeats_only</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>

        <span class="k">return</span> <span class="s1">&#39;BAAB&#39;</span>

    <span class="c1"># 6 node paths with 3x2 repeats</span>

    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">repeated</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">metapath</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>

        <span class="k">if</span> <span class="n">repeats_only</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">repeats_only</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>

            <span class="k">return</span> <span class="s1">&#39;repeat_around&#39;</span>

        <span class="c1"># AABCCB or AABCBC</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">grouped</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">grouped</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>

            <span class="k">return</span> <span class="s1">&#39;disjoint_groups&#39;</span>

        <span class="c1"># ABA CC B</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">repeats_only</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">grouped</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

            <span class="k">return</span> <span class="s1">&#39;interior_complete_group&#39;</span>

        <span class="c1"># most complicated len 6</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="k">return</span> <span class="s1">&#39;other&#39;</span>

    <span class="k">else</span><span class="p">:</span>

        <span class="c1"># Multi-repeats that aren&#39;t disjoint, eg. ABCBAC</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">repeated</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>

            <span class="n">logging</span><span class="o">.</span><span class="kp">info</span><span class="p">(</span>

                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">metapath</span><span class="si">}</span><span class="s2">: Only two overlapping repeats currently supported&quot;</span>

            <span class="p">)</span>

            <span class="k">return</span> <span class="s1">&#39;other&#39;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">metanodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>

            <span class="n">logging</span><span class="o">.</span><span class="kp">info</span><span class="p">(</span>

                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">metapath</span><span class="si">}</span><span class="s2">: Complex metapaths of length &gt; 4 are not yet &quot;</span>

                <span class="sa">f</span><span class="s2">&quot;supported&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="s1">&#39;other&#39;</span>

        <span class="k">assert</span> <span class="kc">False</span>

<span class="k">def</span> <span class="nf">get_segments</span><span class="p">(</span><span class="n">metagraph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Split a metapath into segments of recognized groups and non-repeated</span>

<span class="sd">    nodes. Groups include BAAB, BABA, disjoint short- and long-repeats.</span>

<span class="sd">    Returns an error for categorization &#39;other&#39;.</span>

<span class="sd">    Parameters</span>

<span class="sd">    ----------</span>

<span class="sd">    metagraph : hetnetpy.hetnet.MetaGraph</span>

<span class="sd">    metapath : hetnetpy.hetnet.Metapath</span>

<span class="sd">    Returns</span>

<span class="sd">    -------</span>

<span class="sd">    list</span>

<span class="sd">        list of metapaths. If the metapath is not segmentable or is already</span>

<span class="sd">        fully simplified (eg. GiGaDaG), then the list will have only one</span>

<span class="sd">        element.</span>

<span class="sd">    Examples</span>

<span class="sd">    --------</span>

<span class="sd">    &#39;CbGaDaGaD&#39; -&gt; [&#39;CbG&#39;, &#39;GaD&#39;, &#39;GaG&#39;, &#39;GaD&#39;]</span>

<span class="sd">    &#39;GbCpDaGaD&#39; -&gt; [&#39;GbCpD&#39;, &#39;DaG&#39;, &#39;GaD&#39;]</span>

<span class="sd">    &#39;CrCbGiGaDrD&#39; -&gt; [&#39;CrC&#39;, &#39;CbG&#39;, &#39;GiG&#39;, &#39;GaD&#39;, &#39;DrD&#39;]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">add_head_tail</span><span class="p">(</span><span class="n">metapath</span><span class="p">,</span> <span class="kp">indices</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;Makes sure that all metanodes are included in segments.</span>

<span class="sd">        Ensures that the first segment goes all the way back to the</span>

<span class="sd">        first metanode. Similarly, makes sure that the last segment</span>

<span class="sd">        includes all metanodes up to the last one.&quot;&quot;&quot;</span>

        <span class="c1"># handle non-duplicated on the front</span>

        <span class="k">if</span> <span class="kp">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>

            <span class="kp">indices</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="kp">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])]</span> <span class="o">+</span> <span class="kp">indices</span>

        <span class="c1"># handle non-duplicated on the end</span>

        <span class="k">if</span> <span class="kp">indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">metapath</span><span class="p">):</span>

            <span class="kp">indices</span> <span class="o">=</span> <span class="kp">indices</span> <span class="o">+</span> <span class="p">[(</span><span class="kp">indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">metapath</span><span class="p">))]</span>

        <span class="k">return</span> <span class="kp">indices</span>

    <span class="n">metapath</span> <span class="o">=</span> <span class="n">metagraph</span><span class="o">.</span><span class="n">get_metapath</span><span class="p">(</span><span class="n">metapath</span><span class="p">)</span>

    <span class="n">category</span> <span class="o">=</span> <span class="n">categorize</span><span class="p">(</span><span class="n">metapath</span><span class="p">)</span>

    <span class="n">metanodes</span> <span class="o">=</span> <span class="n">metapath</span><span class="o">.</span><span class="n">get_nodes</span><span class="p">()</span>

    <span class="n">freq</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">(</span><span class="n">metanodes</span><span class="p">)</span>

    <span class="n">repeated</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">freq</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">freq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">}</span>

    <span class="k">if</span> <span class="n">category</span> <span class="o">==</span> <span class="s1">&#39;no_repeats&#39;</span><span class="p">:</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">metapath</span><span class="p">]</span>

    <span class="k">elif</span> <span class="n">category</span> <span class="o">==</span> <span class="s1">&#39;repeat_around&#39;</span><span class="p">:</span>

        <span class="c1"># Note this is hard-coded and will need to be updated for various</span>

        <span class="c1"># metapath lengths</span>

        <span class="kp">indices</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]]</span>

    <span class="k">elif</span> <span class="n">category</span> <span class="o">==</span> <span class="s1">&#39;disjoint_groups&#39;</span><span class="p">:</span>

        <span class="c1"># CCBABA or CCBAAB or BABACC or BAABCC -&gt; [CC, BABA], etc.</span>

        <span class="n">metanodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">metapath</span><span class="o">.</span><span class="n">get_nodes</span><span class="p">())</span>

        <span class="n">grouped</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">metanodes</span><span class="p">)]</span>

        <span class="kp">indices</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">]]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">grouped</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">else</span> <span class="p">[</span>

            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]]</span>

    <span class="k">elif</span> <span class="n">category</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;disjoint&#39;</span><span class="p">,</span> <span class="s1">&#39;short_repeat&#39;</span><span class="p">,</span> <span class="s1">&#39;long_repeat&#39;</span><span class="p">):</span>

        <span class="kp">indices</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([[</span><span class="n">metanodes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">metapath</span><span class="p">)</span> <span class="o">-</span> <span class="nb">list</span><span class="p">(</span>

            <span class="nb">reversed</span><span class="p">(</span><span class="n">metanodes</span><span class="p">))</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">repeated</span><span class="p">])</span>

        <span class="kp">indices</span> <span class="o">=</span> <span class="n">add_head_tail</span><span class="p">(</span><span class="n">metapath</span><span class="p">,</span> <span class="kp">indices</span><span class="p">)</span>

        <span class="c1"># handle middle cases with non-repeated nodes between disjoint regions</span>

        <span class="c1"># Eg. [[0,2], [3,4]] -&gt; [[0,2],[2,3],[3,4]]</span>

        <span class="n">inds</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="kp">indices</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>

            <span class="n">inds</span><span class="o">.</span><span class="kp">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="kp">indices</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>

                <span class="n">inds</span><span class="o">.</span><span class="kp">append</span><span class="p">([</span><span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="kp">indices</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>

        <span class="kp">indices</span> <span class="o">=</span> <span class="n">inds</span> <span class="o">+</span> <span class="p">[</span><span class="kp">indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

    <span class="k">elif</span> <span class="n">category</span> <span class="o">==</span> <span class="s1">&#39;four_repeat&#39;</span><span class="p">:</span>

        <span class="n">nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">metanodes</span><span class="p">)</span>

        <span class="n">repeat_indices</span> <span class="o">=</span> <span class="p">(</span>

            <span class="p">[[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">metanodes</span><span class="p">)</span>

              <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">metanode</span><span class="p">]</span> <span class="k">for</span> <span class="n">metanode</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">])</span>

        <span class="n">repeat_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">repeat_indices</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>

        <span class="n">simple_repeats</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">repeat_indices</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">group</span><span class="p">]</span>

        <span class="n">seconds</span> <span class="o">=</span> <span class="n">simple_repeats</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="p">[</span><span class="n">simple_repeats</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

        <span class="kp">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">simple_repeats</span><span class="p">,</span> <span class="n">seconds</span><span class="p">))</span>

        <span class="kp">indices</span> <span class="o">=</span> <span class="n">add_head_tail</span><span class="p">(</span><span class="n">metapath</span><span class="p">,</span> <span class="kp">indices</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">category</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;BAAB&#39;</span><span class="p">,</span> <span class="s1">&#39;BABA&#39;</span><span class="p">,</span> <span class="s1">&#39;other&#39;</span><span class="p">,</span> <span class="s1">&#39;interior_complete_group&#39;</span><span class="p">):</span>

        <span class="n">nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">metanodes</span><span class="p">)</span>

        <span class="n">repeat_indices</span> <span class="o">=</span> <span class="p">(</span>

            <span class="p">[[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">metanodes</span><span class="p">)</span>

              <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">metanode</span><span class="p">]</span> <span class="k">for</span> <span class="n">metanode</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">])</span>

        <span class="n">repeat_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">repeat_indices</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>

        <span class="n">simple_repeats</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">repeat_indices</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">group</span><span class="p">]</span>

        <span class="n">inds</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">repeat_indices</span><span class="p">:</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>

                <span class="n">inds</span> <span class="o">+=</span> <span class="n">i</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>

                <span class="n">inds</span><span class="o">.</span><span class="kp">append</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                <span class="n">inds</span><span class="o">.</span><span class="kp">append</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>

                    <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">simple_repeats</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">simple_repeats</span><span class="p">)</span> \

                            <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">i</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">i</span><span class="p">):</span>

                        <span class="n">inds</span><span class="o">.</span><span class="kp">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>

        <span class="n">inds</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">inds</span><span class="p">)</span>

        <span class="n">seconds</span> <span class="o">=</span> <span class="n">inds</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

        <span class="kp">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">inds</span><span class="p">,</span> <span class="n">seconds</span><span class="p">))</span>

        <span class="kp">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="kp">indices</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">==</span> <span class="mi">2</span><span class="p">]</span>

        <span class="kp">indices</span> <span class="o">=</span> <span class="n">add_head_tail</span><span class="p">(</span><span class="n">metapath</span><span class="p">,</span> <span class="kp">indices</span><span class="p">)</span>

    <span class="n">segments</span> <span class="o">=</span> <span class="p">[</span><span class="n">metapath</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="kp">indices</span><span class="p">]</span>

    <span class="n">segments</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">segments</span> <span class="k">if</span> <span class="n">i</span><span class="p">]</span>

    <span class="n">segments</span> <span class="o">=</span> <span class="p">[</span><span class="n">metagraph</span><span class="o">.</span><span class="n">get_metapath</span><span class="p">(</span><span class="n">metaedges</span><span class="p">)</span> <span class="k">for</span> <span class="n">metaedges</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">]</span>

    <span class="c1"># eg: B CC ABA</span>

    <span class="k">if</span> <span class="n">category</span> <span class="o">==</span> <span class="s1">&#39;interior_complete_group&#39;</span><span class="p">:</span>

        <span class="n">segs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">segments</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>

            <span class="k">if</span> <span class="n">segments</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="kp">source</span><span class="p">()</span> <span class="o">==</span> <span class="n">segments</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">target</span><span class="p">():</span>

                <span class="n">edges</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">edges</span> <span class="o">+</span> <span class="n">segments</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">edges</span> <span class="o">+</span> <span class="n">segments</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">edges</span>

                <span class="n">segs</span><span class="o">.</span><span class="kp">append</span><span class="p">(</span><span class="n">metagraph</span><span class="o">.</span><span class="n">get_metapath</span><span class="p">(</span><span class="n">edges</span><span class="p">))</span>

            <span class="k">elif</span> <span class="n">v</span><span class="o">.</span><span class="kp">source</span><span class="p">()</span> <span class="o">==</span> <span class="n">v</span><span class="o">.</span><span class="n">target</span><span class="p">():</span>

                <span class="k">pass</span>

            <span class="k">elif</span> <span class="n">segments</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="kp">source</span><span class="p">()</span> <span class="o">==</span> <span class="n">segments</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">target</span><span class="p">():</span>

                <span class="k">pass</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="n">segs</span><span class="o">.</span><span class="kp">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="n">segs</span><span class="o">.</span><span class="kp">append</span><span class="p">(</span><span class="n">segments</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">segments</span> <span class="o">=</span> <span class="n">segs</span>

    <span class="k">return</span> <span class="n">segments</span>

<span class="k">def</span> <span class="nf">get_all_segments</span><span class="p">(</span><span class="n">metagraph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Return all subsegments of a given metapath, including those segments that</span>

<span class="sd">    appear only after early splits.</span>

<span class="sd">    Parameters</span>

<span class="sd">    ----------</span>

<span class="sd">    metagraph : hetnetpy.hetnet.MetaGraph</span>

<span class="sd">    metapath : hetnetpy.hetnet.MetaPath</span>

<span class="sd">    Returns</span>

<span class="sd">    -------</span>

<span class="sd">    list</span>

<span class="sd">    Example</span>

<span class="sd">    -------</span>

<span class="sd">    &gt;&gt;&gt; get_all_segments(metagraph, CrCbGaDrDaG)</span>

<span class="sd">    [CrC, CbG, GaDrDaG, GaD, DrD, DaG]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">metapath</span> <span class="o">=</span> <span class="n">metagraph</span><span class="o">.</span><span class="n">get_metapath</span><span class="p">(</span><span class="n">metapath</span><span class="p">)</span>

    <span class="n">segments</span> <span class="o">=</span> <span class="n">get_segments</span><span class="p">(</span><span class="n">metagraph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">segments</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">metapath</span><span class="p">]</span>

    <span class="n">all_subsegments</span> <span class="o">=</span> <span class="p">[</span><span class="n">metapath</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">:</span>

        <span class="n">subsegments</span> <span class="o">=</span> <span class="n">get_all_segments</span><span class="p">(</span><span class="n">metagraph</span><span class="p">,</span> <span class="n">segment</span><span class="p">)</span>

        <span class="n">next_split</span> <span class="o">=</span> <span class="n">subsegments</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subsegments</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">[]</span>

        <span class="n">all_subsegments</span> <span class="o">=</span> <span class="n">all_subsegments</span> <span class="o">+</span> <span class="p">[</span><span class="n">segment</span><span class="p">]</span> <span class="o">+</span> <span class="n">next_split</span>

    <span class="k">return</span> <span class="n">all_subsegments</span>

<span class="k">def</span> <span class="nf">order_segments</span><span class="p">(</span><span class="n">metagraph</span><span class="p">,</span> <span class="n">metapaths</span><span class="p">,</span> <span class="n">store_inverses</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Gives the frequencies of metapath segments that occur when computing DWPC.</span>

<span class="sd">    In DWPC computation, metapaths are split a number of times for simpler computation.</span>

<span class="sd">    This function finds the frequencies that segments would be used when computing</span>

<span class="sd">    DWPC for all given metapaths. For the targeted caching of the most frequently</span>

<span class="sd">    used segments.</span>

<span class="sd">    Parameters</span>

<span class="sd">    ----------</span>

<span class="sd">    metagraph : hetnetpy.hetnet.MetaGraph</span>

<span class="sd">    metapaths : list</span>

<span class="sd">        list of hetnetpy.hetnet.MetaPath objects</span>

<span class="sd">    store_inverses : bool</span>

<span class="sd">        Whether or not to include both forward and backward directions of segments.</span>

<span class="sd">        For example, if False: [CbG, GbC] -&gt; [CbG, CbG], else no change.</span>

<span class="sd">    Returns</span>

<span class="sd">    -------</span>

<span class="sd">    collections.Counter</span>

<span class="sd">        Number of times each metapath segment appears when getting all segments.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">all_segments</span> <span class="o">=</span> <span class="p">[</span><span class="n">segment</span> <span class="k">for</span> <span class="n">metapath</span> <span class="ow">in</span> <span class="n">metapaths</span> <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">get_all_segments</span><span class="p">(</span><span class="n">metagraph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">)]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">store_inverses</span><span class="p">:</span>

        <span class="c1"># Change all instances of inverted segments to the same direction, using a first-seen ordering</span>

        <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="n">aligned_segments</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">all_segments</span><span class="p">:</span>

            <span class="kp">add</span> <span class="o">=</span> <span class="n">segment</span><span class="o">.</span><span class="n">inverse</span> <span class="k">if</span> <span class="n">segment</span><span class="o">.</span><span class="n">inverse</span> <span class="ow">in</span> <span class="n">seen</span> <span class="k">else</span> <span class="n">segment</span>

            <span class="n">aligned_segments</span><span class="o">.</span><span class="kp">append</span><span class="p">(</span><span class="kp">add</span><span class="p">)</span>

            <span class="n">seen</span><span class="o">.</span><span class="kp">add</span><span class="p">(</span><span class="kp">add</span><span class="p">)</span>

        <span class="n">all_segments</span> <span class="o">=</span> <span class="n">aligned_segments</span>

    <span class="n">segment_counts</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">(</span><span class="n">all_segments</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">segment_counts</span>

<span class="k">def</span> <span class="nf">remove_diag</span><span class="p">(</span><span class="kp">mat</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Set the main diagonal of a square matrix to zeros.&quot;&quot;&quot;</span>

    <span class="k">assert</span> <span class="kp">mat</span><span class="o">.</span><span class="kp">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="kp">mat</span><span class="o">.</span><span class="kp">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># must be square</span>

    <span class="k">if</span> <span class="n">sparse</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="kp">mat</span><span class="p">):</span>

        <span class="k">return</span> <span class="kp">mat</span> <span class="o">-</span> <span class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="kp">mat</span><span class="o">.</span><span class="kp">diagonal</span><span class="p">(),</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>

        <span class="k">return</span> <span class="kp">mat</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="kp">diag</span><span class="p">(</span><span class="kp">mat</span><span class="o">.</span><span class="kp">diagonal</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">_degree_weight</span><span class="p">(</span><span class="kp">matrix</span><span class="p">,</span> <span class="n">damping</span><span class="p">,</span> <span class="kp">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Normalize an adjacency matrix by the in and out degree.&quot;&quot;&quot;</span>

    <span class="kp">matrix</span> <span class="o">=</span> <span class="n">hetmatpy</span><span class="o">.</span><span class="kp">matrix</span><span class="o">.</span><span class="n">copy_array</span><span class="p">(</span><span class="kp">matrix</span><span class="p">,</span> <span class="kp">copy</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

    <span class="n">row_sums</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="kp">array</span><span class="p">(</span><span class="kp">matrix</span><span class="o">.</span><span class="kp">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span><span class="o">.</span><span class="kp">flatten</span><span class="p">()</span>

    <span class="n">column_sums</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="kp">array</span><span class="p">(</span><span class="kp">matrix</span><span class="o">.</span><span class="kp">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span><span class="o">.</span><span class="kp">flatten</span><span class="p">()</span>

    <span class="kp">matrix</span> <span class="o">=</span> <span class="n">hetmatpy</span><span class="o">.</span><span class="kp">matrix</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="kp">matrix</span><span class="p">,</span> <span class="n">row_sums</span><span class="p">,</span> <span class="s1">&#39;rows&#39;</span><span class="p">,</span> <span class="n">damping</span><span class="p">)</span>

    <span class="kp">matrix</span> <span class="o">=</span> <span class="n">hetmatpy</span><span class="o">.</span><span class="kp">matrix</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="kp">matrix</span><span class="p">,</span> <span class="n">column_sums</span><span class="p">,</span> <span class="s1">&#39;columns&#39;</span><span class="p">,</span> <span class="n">damping</span><span class="p">)</span>

    <span class="k">return</span> <span class="kp">matrix</span>

<span class="k">def</span> <span class="nf">_dwpc_approx</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>

                 <span class="kp">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Compute an approximation of DWPC. Only removes the diagonal for the first</span>

<span class="sd">    repeated node, and any disjoint repetitions that follow the last occurrence</span>

<span class="sd">    of the first repeating node.</span>

<span class="sd">    Examples</span>

<span class="sd">    --------</span>

<span class="sd">    GiGbCrC -&gt; Identical output to DWPC</span>

<span class="sd">    GiGbCbGiG -&gt; Approximation</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">row_names</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Find the first repeated metanode and where it occurs</span>

    <span class="n">nodes</span> <span class="o">=</span> <span class="n">metapath</span><span class="o">.</span><span class="n">get_nodes</span><span class="p">()</span>

    <span class="n">repeated_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]]</span>

    <span class="n">first_repeat</span> <span class="o">=</span> <span class="n">repeated_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">repeated_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">first_repeat</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">segment</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">repeated_indices</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>

        <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="n">dwpc</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">[</span><span class="n">repeated_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">segment</span><span class="p">],</span>

                                       <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span>

                                       <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">row_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">row_names</span> <span class="o">=</span> <span class="n">rows</span>

    <span class="c1"># Add head and tail segments, if applicable</span>

    <span class="k">if</span> <span class="n">repeated_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>

        <span class="n">row_names</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">head_seg</span> <span class="o">=</span> <span class="n">dwwc</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">repeated_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span>

                                      <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

        <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="n">head_seg</span> <span class="o">@</span> <span class="n">dwpc_matrix</span>

    <span class="k">if</span> <span class="n">nodes</span><span class="p">[</span><span class="n">repeated_indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">!=</span> <span class="n">nodes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">tail_seg</span> <span class="o">=</span> <span class="n">dwpc</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">[</span><span class="n">repeated_indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:],</span> <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span>

                                 <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

        <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="n">dwpc_matrix</span> <span class="o">@</span> <span class="n">tail_seg</span>

    <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="n">sparsify_or_densify</span><span class="p">(</span><span class="n">dwpc_matrix</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">row_names</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">dwpc_matrix</span>

<span class="k">def</span> <span class="nf">_dwpc_disjoint</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>

                   <span class="kp">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;DWPC for disjoint repeats or disjoint groups&quot;&quot;&quot;</span>

    <span class="n">segments</span> <span class="o">=</span> <span class="n">get_segments</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">metagraph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">)</span>

    <span class="n">row_names</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">col_names</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">:</span>

        <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">seg_matrix</span> <span class="o">=</span> <span class="n">dwpc</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">segment</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span>

                                      <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">row_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">row_names</span> <span class="o">=</span> <span class="n">rows</span>

        <span class="k">if</span> <span class="n">segment</span> <span class="ow">is</span> <span class="n">segments</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>

            <span class="n">col_names</span> <span class="o">=</span> <span class="n">cols</span>

        <span class="k">if</span> <span class="n">dwpc_matrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="n">seg_matrix</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="n">dwpc_matrix</span> <span class="o">@</span> <span class="n">seg_matrix</span>

    <span class="k">return</span> <span class="n">row_names</span><span class="p">,</span> <span class="n">col_names</span><span class="p">,</span> <span class="n">dwpc_matrix</span>

<span class="k">def</span> <span class="nf">_dwpc_repeat_around</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>

                        <span class="kp">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    DWPC for situations in which we have a surrounding repeat like</span>

<span class="sd">    B----B, where the middle group is a more complicated group. The</span>

<span class="sd">    purpose of this function is just as an order-of-operations simplification</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">segments</span> <span class="o">=</span> <span class="n">get_segments</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">metagraph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">)</span>

    <span class="n">mid</span> <span class="o">=</span> <span class="n">dwpc</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">segments</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span>

               <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span>

    <span class="n">row_names</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">adj0</span> <span class="o">=</span> <span class="n">dwpc</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">segments</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span>

                                 <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

    <span class="n">rows</span><span class="p">,</span> <span class="n">col_names</span><span class="p">,</span> <span class="n">adj1</span> <span class="o">=</span> <span class="n">dwpc</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">segments</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span>

                                 <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

    <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="n">remove_diag</span><span class="p">(</span><span class="n">adj0</span> <span class="o">@</span> <span class="n">mid</span> <span class="o">@</span> <span class="n">adj1</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">row_names</span><span class="p">,</span> <span class="n">col_names</span><span class="p">,</span> <span class="n">dwpc_matrix</span>

<span class="k">def</span> <span class="nf">_dwpc_baab</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>

               <span class="kp">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    A function to handle metapath (segments) of the form BAAB.</span>

<span class="sd">    This function will handle arbitrary lengths of this repeated</span>

<span class="sd">    pattern. For example, ABCCBA, ABCDDCBA, etc. all work with this</span>

<span class="sd">    function. Random non-repeat inserts are supported. The metapath</span>

<span class="sd">    must start and end with a repeated node, though.</span>

<span class="sd">    Covers all variants of symmetrically repeated metanodes with</span>

<span class="sd">    support for random non-repeat metanode inserts at any point.</span>

<span class="sd">    Parameters</span>

<span class="sd">    ----------</span>

<span class="sd">    graph : hetnetpy.hetnet.Graph</span>

<span class="sd">    metapath : hetnetpy.hetnet.MetaPath</span>

<span class="sd">    damping : float</span>

<span class="sd">    dense_threshold : float (0 &lt;= dense_threshold &lt;= 1)</span>

<span class="sd">        sets the density threshold above which a sparse matrix will be</span>

<span class="sd">        converted to a dense automatically.</span>

<span class="sd">    dtype : dtype object</span>

<span class="sd">    Examples</span>

<span class="sd">    --------</span>

<span class="sd">    Acceptable metapaths forms include the following:</span>

<span class="sd">    B-A-A-B</span>

<span class="sd">    B-C-A-A-B</span>

<span class="sd">    B-C-A-D-A-E-B</span>

<span class="sd">    B-C-D-E-A-F-A-B</span>

<span class="sd">    C-B-A-A-B-D-E</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Segment the metapath</span>

    <span class="n">segments</span> <span class="o">=</span> <span class="n">get_segments</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">metagraph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">)</span>

    <span class="c1"># Start with the middle group (A-A or A-...-A in BAAB)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">segments</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="kp">source</span><span class="p">()</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">target</span><span class="p">():</span>

            <span class="n">mid_seg</span> <span class="o">=</span> <span class="n">s</span>

            <span class="n">mid_ind</span> <span class="o">=</span> <span class="n">i</span>

    <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">dwpc_mid</span> <span class="o">=</span> <span class="n">dwpc</span><span class="p">(</span>

        <span class="n">graph</span><span class="p">,</span> <span class="n">mid_seg</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span>

        <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

    <span class="n">dwpc_mid</span> <span class="o">=</span> <span class="n">remove_diag</span><span class="p">(</span><span class="n">dwpc_mid</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

    <span class="c1"># Get two indices for the segments ahead of and behind the middle region</span>

    <span class="n">head_ind</span> <span class="o">=</span> <span class="n">mid_ind</span>

    <span class="n">tail_ind</span> <span class="o">=</span> <span class="n">mid_ind</span>

    <span class="k">while</span> <span class="n">head_ind</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">tail_ind</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">segments</span><span class="p">):</span>

        <span class="n">head_ind</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="n">tail_ind</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">head</span> <span class="o">=</span> <span class="n">segments</span><span class="p">[</span><span class="n">head_ind</span><span class="p">]</span> <span class="k">if</span> <span class="n">head_ind</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="n">tail</span> <span class="o">=</span> <span class="n">segments</span><span class="p">[</span><span class="n">tail_ind</span><span class="p">]</span> <span class="k">if</span> <span class="n">tail_ind</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">segments</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="c1"># Multiply on the head</span>

        <span class="k">if</span> <span class="n">head</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">row_names</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">dwpc_head</span> <span class="o">=</span> <span class="n">dwpc</span><span class="p">(</span>

                <span class="n">graph</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span>

                <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

            <span class="n">dwpc_mid</span> <span class="o">=</span> <span class="n">dwpc_head</span> <span class="o">@</span> <span class="n">dwpc_mid</span>

        <span class="c1"># Multiply on the tail</span>

        <span class="k">if</span> <span class="n">tail</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">rows</span><span class="p">,</span> <span class="n">col_names</span><span class="p">,</span> <span class="n">dwpc_tail</span> <span class="o">=</span> <span class="n">dwpc</span><span class="p">(</span>

                <span class="n">graph</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span>

                <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

            <span class="n">dwpc_mid</span> <span class="o">=</span> <span class="n">dwpc_mid</span> <span class="o">@</span> <span class="n">dwpc_tail</span>

        <span class="c1"># Remove the diagonal if the head and tail are repeats</span>

        <span class="k">if</span> <span class="n">head</span> <span class="ow">and</span> <span class="n">tail</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">head</span><span class="o">.</span><span class="kp">source</span><span class="p">()</span> <span class="o">==</span> <span class="n">tail</span><span class="o">.</span><span class="n">target</span><span class="p">():</span>

                <span class="n">dwpc_mid</span> <span class="o">=</span> <span class="n">remove_diag</span><span class="p">(</span><span class="n">dwpc_mid</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">row_names</span><span class="p">,</span> <span class="n">col_names</span><span class="p">,</span> <span class="n">dwpc_mid</span>

<span class="k">def</span> <span class="nf">_dwpc_baba</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>

               <span class="kp">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Computes the degree-weighted path count for overlapping metanode</span>

<span class="sd">    repeats of the form B-A-B-A. Supports random inserts.</span>

<span class="sd">    Segment must start with B and end with A. AXBYAZB</span>

<span class="sd">    Also supports four-node repeats of a single node, including random,</span>

<span class="sd">    non-repeated inserts. For example, ABBBXBC, AAAA.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">segments</span> <span class="o">=</span> <span class="n">get_segments</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">metagraph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">)</span>

    <span class="n">seg_axb</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">segments</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]):</span>

        <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="kp">source</span><span class="p">()</span> <span class="o">==</span> <span class="n">segments</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="kp">source</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">seg_axb</span><span class="p">:</span>

            <span class="n">seg_axb</span> <span class="o">=</span> <span class="n">s</span>

            <span class="n">seg_bya</span> <span class="o">=</span> <span class="n">segments</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

            <span class="n">seg_azb</span> <span class="o">=</span> <span class="n">segments</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>

            <span class="n">seg_cda</span> <span class="o">=</span> <span class="n">segments</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="kc">None</span>

            <span class="n">seg_bed</span> <span class="o">=</span> <span class="n">segments</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">segments</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">seg_azb</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="c1"># Collect segment DWPC and corrections</span>

    <span class="n">row_names</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">axb</span> <span class="o">=</span> <span class="n">dwpc</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">seg_axb</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span>

                                <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

    <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">bya</span> <span class="o">=</span> <span class="n">dwpc</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">seg_bya</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span>

                           <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

    <span class="n">rows</span><span class="p">,</span> <span class="n">col_names</span><span class="p">,</span> <span class="n">azb</span> <span class="o">=</span> <span class="n">dwpc</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">seg_azb</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span>

                                <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

    <span class="n">correction_a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="kp">diag</span><span class="p">((</span><span class="n">axb</span> <span class="o">@</span> <span class="n">bya</span><span class="p">)</span><span class="o">.</span><span class="kp">diagonal</span><span class="p">())</span> <span class="o">@</span> <span class="n">azb</span> <span class="k">if</span> \

        <span class="ow">not</span> <span class="n">sparse</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">axb</span><span class="p">)</span> <span class="k">else</span> \

        <span class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">((</span><span class="n">axb</span> <span class="o">@</span> <span class="n">bya</span><span class="p">)</span><span class="o">.</span><span class="kp">diagonal</span><span class="p">())</span> <span class="o">@</span> <span class="n">azb</span>

    <span class="n">correction_b</span> <span class="o">=</span> <span class="n">axb</span> <span class="o">@</span> <span class="n">numpy</span><span class="o">.</span><span class="kp">diag</span><span class="p">((</span><span class="n">bya</span> <span class="o">@</span> <span class="n">azb</span><span class="p">)</span><span class="o">.</span><span class="kp">diagonal</span><span class="p">())</span> <span class="k">if</span> \

        <span class="ow">not</span> <span class="n">sparse</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">bya</span><span class="p">)</span> <span class="k">else</span> \

        <span class="n">axb</span> <span class="o">@</span> <span class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">((</span><span class="n">bya</span> <span class="o">@</span> <span class="n">azb</span><span class="p">)</span><span class="o">.</span><span class="kp">diagonal</span><span class="p">())</span>

    <span class="n">correction_c</span> <span class="o">=</span> <span class="n">axb</span> <span class="o">*</span> <span class="n">bya</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">azb</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">sparse</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">bya</span><span class="p">)</span> <span class="k">else</span> \

        <span class="p">(</span><span class="n">axb</span><span class="o">.</span><span class="kp">multiply</span><span class="p">(</span><span class="n">bya</span><span class="o">.</span><span class="n">T</span><span class="p">))</span><span class="o">.</span><span class="kp">multiply</span><span class="p">(</span><span class="n">azb</span><span class="p">)</span>

    <span class="c1"># Apply the corrections</span>

    <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="n">axb</span> <span class="o">@</span> <span class="n">bya</span> <span class="o">@</span> <span class="n">azb</span> <span class="o">-</span> <span class="n">correction_a</span> <span class="o">-</span> <span class="n">correction_b</span> <span class="o">+</span> <span class="n">correction_c</span>

    <span class="k">if</span> <span class="n">seg_axb</span><span class="o">.</span><span class="kp">source</span> <span class="o">==</span> <span class="n">seg_azb</span><span class="o">.</span><span class="n">target</span><span class="p">:</span>

        <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="n">remove_diag</span><span class="p">(</span><span class="n">dwpc_matrix</span><span class="p">)</span>

    <span class="c1"># Account for possible head and tail segments outside the BABA group</span>

    <span class="k">if</span> <span class="n">seg_cda</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

        <span class="n">row_names</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">cda</span> <span class="o">=</span> <span class="n">dwpc</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">seg_cda</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span>

                                    <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

        <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="n">cda</span> <span class="o">@</span> <span class="n">dwpc_matrix</span>

    <span class="k">if</span> <span class="n">seg_bed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

        <span class="n">rows</span><span class="p">,</span> <span class="n">col_names</span><span class="p">,</span> <span class="n">bed</span> <span class="o">=</span> <span class="n">dwpc</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">seg_bed</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span>

                                    <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

        <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="n">dwpc_matrix</span> <span class="o">@</span> <span class="n">bed</span>

    <span class="k">return</span> <span class="n">row_names</span><span class="p">,</span> <span class="n">col_names</span><span class="p">,</span> <span class="n">dwpc_matrix</span>

<span class="k">def</span> <span class="nf">_dwpc_short_repeat</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>

                       <span class="kp">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    One metanode repeated 3 or fewer times (A-A-A), not (A-A-A-A)</span>

<span class="sd">    This can include other random inserts, so long as they are not</span>

<span class="sd">    repeats. Must start and end with the repeated node. Acceptable</span>

<span class="sd">    examples: (A-B-A-A), (A-B-A-C-D-E-F-A), (A-B-A-A), etc.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">segments</span> <span class="o">=</span> <span class="n">get_segments</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">metagraph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">segments</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">3</span>

    <span class="c1"># Account for different head and tail possibilities.</span>

    <span class="n">head_segment</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">tail_segment</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">dwpc_tail</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Label the segments as head, tail, and repeat</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">segment</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">segments</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">segment</span><span class="o">.</span><span class="kp">source</span><span class="p">()</span> <span class="o">==</span> <span class="n">segment</span><span class="o">.</span><span class="n">target</span><span class="p">():</span>

            <span class="n">repeat_segment</span> <span class="o">=</span> <span class="n">segment</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>

                <span class="n">head_segment</span> <span class="o">=</span> <span class="n">segment</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="n">tail_segment</span> <span class="o">=</span> <span class="n">segment</span>

    <span class="c1"># Calculate DWPC for the middle (&quot;repeat&quot;) segment</span>

    <span class="n">repeated_metanode</span> <span class="o">=</span> <span class="n">repeat_segment</span><span class="o">.</span><span class="kp">source</span><span class="p">()</span>

    <span class="n">index_of_repeats</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">repeat_segment</span><span class="o">.</span><span class="n">get_nodes</span><span class="p">())</span> <span class="k">if</span>

                        <span class="n">v</span> <span class="o">==</span> <span class="n">repeated_metanode</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">metaedge</span> <span class="ow">in</span> <span class="n">repeat_segment</span><span class="p">[:</span><span class="n">index_of_repeats</span><span class="p">[</span><span class="mi">1</span><span class="p">]]:</span>

        <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">adj</span> <span class="o">=</span> <span class="n">hetmatpy</span><span class="o">.</span><span class="kp">matrix</span><span class="o">.</span><span class="n">metaedge_to_adjacency_matrix</span><span class="p">(</span>

            <span class="n">graph</span><span class="p">,</span> <span class="n">metaedge</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">,</span>

            <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">)</span>

        <span class="n">adj</span> <span class="o">=</span> <span class="n">_degree_weight</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">damping</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dwpc_matrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">row_names</span> <span class="o">=</span> <span class="n">rows</span>

            <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="n">adj</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="n">dwpc_matrix</span> <span class="o">@</span> <span class="n">adj</span>

    <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="n">remove_diag</span><span class="p">(</span><span class="n">dwpc_matrix</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

    <span class="c1"># Extra correction for random metanodes in the repeat segment</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">index_of_repeats</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>

        <span class="k">for</span> <span class="n">metaedge</span> <span class="ow">in</span> <span class="n">repeat_segment</span><span class="p">[</span><span class="n">index_of_repeats</span><span class="p">[</span><span class="mi">1</span><span class="p">]:]:</span>

            <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">adj</span> <span class="o">=</span> <span class="n">hetmatpy</span><span class="o">.</span><span class="kp">matrix</span><span class="o">.</span><span class="n">metaedge_to_adjacency_matrix</span><span class="p">(</span>

                <span class="n">graph</span><span class="p">,</span> <span class="n">metaedge</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">,</span>

                <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">)</span>

            <span class="n">adj</span> <span class="o">=</span> <span class="n">_degree_weight</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">damping</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">dwpc_tail</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

                <span class="n">dwpc_tail</span> <span class="o">=</span> <span class="n">adj</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="n">dwpc_tail</span> <span class="o">=</span> <span class="n">dwpc_tail</span> <span class="o">@</span> <span class="n">adj</span>

        <span class="n">dwpc_tail</span> <span class="o">=</span> <span class="n">remove_diag</span><span class="p">(</span><span class="n">dwpc_tail</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

        <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="n">dwpc_matrix</span> <span class="o">@</span> <span class="n">dwpc_tail</span>

        <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="n">remove_diag</span><span class="p">(</span><span class="n">dwpc_matrix</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

    <span class="n">col_names</span> <span class="o">=</span> <span class="n">cols</span>

    <span class="k">if</span> <span class="n">head_segment</span><span class="p">:</span>

        <span class="n">row_names</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">head_dwpc</span> <span class="o">=</span> <span class="n">dwpc</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">head_segment</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span>

                                          <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span>

                                          <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

        <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="n">head_dwpc</span> <span class="o">@</span> <span class="n">dwpc_matrix</span>

    <span class="k">if</span> <span class="n">tail_segment</span><span class="p">:</span>

        <span class="n">rows</span><span class="p">,</span> <span class="n">col_names</span><span class="p">,</span> <span class="n">tail_dwpc</span> <span class="o">=</span> <span class="n">dwpc</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">tail_segment</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span>

                                          <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span>

                                          <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

        <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="n">dwpc_matrix</span> <span class="o">@</span> <span class="n">tail_dwpc</span>

    <span class="k">return</span> <span class="n">row_names</span><span class="p">,</span> <span class="n">col_names</span><span class="p">,</span> <span class="n">dwpc_matrix</span>

<span class="k">def</span> <span class="nf">_node_to_children</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">metapath_index</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>

                      <span class="n">history</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Returns a history adjusted list of child nodes. Used in _dwpc_general_case.</span>

<span class="sd">    Parameters</span>

<span class="sd">    ----------</span>

<span class="sd">    graph : hetnetpy.hetnet.Graph</span>

<span class="sd">    metapath : hetnetpy.hetnet.MetaPath</span>

<span class="sd">    node : numpy.ndarray</span>

<span class="sd">    metapath_index : int</span>

<span class="sd">    damping : float</span>

<span class="sd">    history : numpy.ndarray</span>

<span class="sd">    dtype : dtype object</span>

<span class="sd">    Returns</span>

<span class="sd">    -------</span>

<span class="sd">    dict</span>

<span class="sd">        List of child nodes and a single numpy.ndarray of the newly</span>

<span class="sd">        updated history vector.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">metaedge</span> <span class="o">=</span> <span class="n">metapath</span><span class="p">[</span><span class="n">metapath_index</span><span class="p">]</span>

    <span class="n">metanodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">metapath</span><span class="o">.</span><span class="n">get_nodes</span><span class="p">())</span>

    <span class="n">freq</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">(</span><span class="n">metanodes</span><span class="p">)</span>

    <span class="n">repeated</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">freq</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">freq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">}</span>

    <span class="k">if</span> <span class="n">history</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

        <span class="n">history</span> <span class="o">=</span> <span class="p">{</span>

            <span class="n">i</span><span class="o">.</span><span class="n">target</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="kp">ones</span><span class="p">(</span>

                <span class="nb">len</span><span class="p">(</span><span class="n">hetmatpy</span><span class="o">.</span><span class="kp">matrix</span><span class="o">.</span><span class="n">metaedge_to_adjacency_matrix</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">i</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

                    <span class="p">),</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">metapath</span> <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">target</span> <span class="ow">in</span> <span class="n">repeated</span>

        <span class="p">}</span>

    <span class="n">history</span> <span class="o">=</span> <span class="n">history</span><span class="o">.</span><span class="kp">copy</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">metaedge</span><span class="o">.</span><span class="kp">source</span> <span class="ow">in</span> <span class="n">history</span><span class="p">:</span>

        <span class="n">history</span><span class="p">[</span><span class="n">metaedge</span><span class="o">.</span><span class="kp">source</span><span class="p">]</span> <span class="o">-=</span> <span class="n">numpy</span><span class="o">.</span><span class="kp">array</span><span class="p">(</span><span class="n">node</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

    <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">adj</span> <span class="o">=</span> <span class="n">hetmatpy</span><span class="o">.</span><span class="kp">matrix</span><span class="o">.</span><span class="n">metaedge_to_adjacency_matrix</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">metaedge</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

    <span class="n">adj</span> <span class="o">=</span> <span class="n">_degree_weight</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">damping</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

    <span class="n">vector</span> <span class="o">=</span> <span class="n">node</span> <span class="o">@</span> <span class="n">adj</span>

    <span class="k">if</span> <span class="n">metaedge</span><span class="o">.</span><span class="n">target</span> <span class="ow">in</span> <span class="n">history</span><span class="p">:</span>

        <span class="n">vector</span> <span class="o">*=</span> <span class="n">history</span><span class="p">[</span><span class="n">metaedge</span><span class="o">.</span><span class="n">target</span><span class="p">]</span>

    <span class="n">children</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">numpy</span><span class="o">.</span><span class="kp">diag</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="kp">any</span><span class="p">()]</span>

    <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;children&#39;</span><span class="p">:</span> <span class="n">children</span><span class="p">,</span> <span class="s1">&#39;history&#39;</span><span class="p">:</span> <span class="n">history</span><span class="p">,</span>

            <span class="s1">&#39;next_index&#39;</span><span class="p">:</span> <span class="n">metapath_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">}</span>

<span class="k">def</span> <span class="nf">_dwpc_general_case</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    A slow but general function to compute the degree-weighted</span>

<span class="sd">    path count. Works by splitting the metapath at junctions</span>

<span class="sd">    where one node is joined to multiple nodes over a metaedge.</span>

<span class="sd">    Parameters</span>

<span class="sd">    ----------</span>

<span class="sd">    graph : hetnetpy.hetnet.Graph</span>

<span class="sd">    metapath : hetnetpy.hetnet.MetaPath</span>

<span class="sd">    damping : float</span>

<span class="sd">    dtype : dtype object</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dwpc_step</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">_node_to_children</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span>

                                  <span class="n">metapath</span><span class="o">=</span><span class="n">metapath</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span>

                                  <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

    <span class="n">start_nodes</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">adj</span> <span class="o">=</span> <span class="n">hetmatpy</span><span class="o">.</span><span class="kp">matrix</span><span class="o">.</span><span class="n">metaedge_to_adjacency_matrix</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="n">rows</span><span class="p">,</span> <span class="n">fin_nodes</span><span class="p">,</span> <span class="n">adj</span> <span class="o">=</span> <span class="n">hetmatpy</span><span class="o">.</span><span class="kp">matrix</span><span class="o">.</span><span class="n">metaedge_to_adjacency_matrix</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">number_start</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">start_nodes</span><span class="p">)</span>

    <span class="n">number_end</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fin_nodes</span><span class="p">)</span>

    <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">metapath</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_start</span><span class="p">):</span>

            <span class="n">search</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="kp">zeros</span><span class="p">(</span><span class="n">number_start</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

            <span class="n">search</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="n">step1</span> <span class="o">=</span> <span class="p">[</span><span class="n">dwpc_step</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="n">search</span><span class="p">,</span> <span class="n">metapath_index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">history</span><span class="o">=</span><span class="kc">None</span><span class="p">)]</span>

            <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="k">while</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">metapath</span><span class="p">):</span>

                <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="n">step2</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">step1</span><span class="p">:</span>

                    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">group</span><span class="p">[</span><span class="s1">&#39;children&#39;</span><span class="p">]:</span>

                        <span class="n">hist</span> <span class="o">=</span> <span class="kp">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">group</span><span class="p">[</span><span class="s1">&#39;history&#39;</span><span class="p">])</span>

                        <span class="n">out</span> <span class="o">=</span> <span class="n">dwpc_step</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="n">child</span><span class="p">,</span>

                                        <span class="n">metapath_index</span><span class="o">=</span><span class="n">group</span><span class="p">[</span><span class="s1">&#39;next_index&#39;</span><span class="p">],</span>

                                        <span class="n">history</span><span class="o">=</span><span class="n">hist</span><span class="p">)</span>

                        <span class="k">if</span> <span class="n">out</span><span class="p">[</span><span class="s1">&#39;children&#39;</span><span class="p">]:</span>

                            <span class="n">step2</span><span class="o">.</span><span class="kp">append</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

                    <span class="n">step1</span> <span class="o">=</span> <span class="n">step2</span>

            <span class="n">final_children</span> <span class="o">=</span> <span class="p">[</span><span class="n">group</span> <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">step2</span>

                              <span class="k">if</span> <span class="n">group</span><span class="p">[</span><span class="s1">&#39;children&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="p">[]]</span>

            <span class="n">end_nodes</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>

                <span class="p">[</span><span class="n">child</span> <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">final_children</span>

                 <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">group</span><span class="p">[</span><span class="s1">&#39;children&#39;</span><span class="p">]])</span>

            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">end_nodes</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>

                <span class="n">end_nodes</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="kp">zeros</span><span class="p">(</span><span class="n">number_end</span><span class="p">)</span>

            <span class="n">dwpc_matrix</span><span class="o">.</span><span class="kp">append</span><span class="p">(</span><span class="n">end_nodes</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>

        <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="n">_degree_weight</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

    <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="kp">array</span><span class="p">(</span><span class="n">dwpc_matrix</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">start_nodes</span><span class="p">,</span> <span class="n">fin_nodes</span><span class="p">,</span> <span class="n">dwpc_matrix</span>

<span class="c1"># Default DWWC method to use, when not specified</span>

<span class="n">default_dwwc_method</span> <span class="o">=</span> <span class="n">dwwc_chain</span>
</code></pre></div>


</details>
<h2 id="functions">Functions</h2>
<h3 id="categorize">categorize</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">categorize</span><span class="p">(</span>
    <span class="n">metapath</span>
<span class="p">)</span>
</code></pre></div>


<p>Returns the classification of a given metapath as one of
a set of metapath types which we approach differently.</p>
<h2 id="parameters">Parameters</h2>
<p>metapath : hetnetpy.hetnet.MetaPath</p>
<h2 id="returns">Returns</h2>
<p>classification : string
    One of ['no_repeats', 'disjoint', 'short_repeat',
            'long_repeat', 'BAAB', 'BABA', 'repeat_around',
             'interior_complete_group', 'disjoint_groups', 'other']
Examples</p>
<hr />
<p>GbCtDlA -&gt; 'no_repeats'
GiGiG   -&gt; 'short_repeat'
GiGiGcG -&gt; 'four_repeat'
GiGcGiGiG -&gt; 'long_repeat'
GiGbCrC -&gt; 'disjoint'
GbCbGbC -&gt; 'BABA'
GbCrCbG -&gt; 'BAAB'
DaGiGbCrC -&gt; 'disjoint'
GiGaDpCrC -&gt; 'disjoint'
GiGbCrCpDrD -&gt; 'disjoint'
GbCpDaGbCpD -&gt; 'other'
GbCrCrCrCrCbG -&gt; 'other'</p>
<details class="example"><summary>View Source</summary><div class="codehilite"><pre><span></span><code>def categorize<span class="p">(</span>metapath<span class="p">):</span>

    <span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    Returns the classification of a given metapath as one of</span>

<span class="s2">    a set of metapath types which we approach differently.</span>

<span class="s2">    Parameters</span>

<span class="s2">    ----------</span>

<span class="s2">    metapath : hetnetpy.hetnet.MetaPath</span>

<span class="s2">    Returns</span>

<span class="s2">    -------</span>

<span class="s2">    classification : string</span>

<span class="s2">        One of [&#39;no_repeats&#39;, &#39;disjoint&#39;, &#39;short_repeat&#39;,</span>

<span class="s2">                &#39;long_repeat&#39;, &#39;BAAB&#39;, &#39;BABA&#39;, &#39;repeat_around&#39;,</span>

<span class="s2">                 &#39;interior_complete_group&#39;, &#39;disjoint_groups&#39;, &#39;other&#39;]</span>

<span class="s2">    Examples</span>

<span class="s2">    --------</span>

<span class="s2">    GbCtDlA -&gt; &#39;no_repeats&#39;</span>

<span class="s2">    GiGiG   -&gt; &#39;short_repeat&#39;</span>

<span class="s2">    GiGiGcG -&gt; &#39;four_repeat&#39;</span>

<span class="s2">    GiGcGiGiG -&gt; &#39;long_repeat&#39;</span>

<span class="s2">    GiGbCrC -&gt; &#39;disjoint&#39;</span>

<span class="s2">    GbCbGbC -&gt; &#39;BABA&#39;</span>

<span class="s2">    GbCrCbG -&gt; &#39;BAAB&#39;</span>

<span class="s2">    DaGiGbCrC -&gt; &#39;disjoint&#39;</span>

<span class="s2">    GiGaDpCrC -&gt; &#39;disjoint&#39;</span>

<span class="s2">    GiGbCrCpDrD -&gt; &#39;disjoint&#39;</span>

<span class="s2">    GbCpDaGbCpD -&gt; &#39;other&#39;</span>

<span class="s2">    GbCrCrCrCrCbG -&gt; &#39;other&#39;</span>

<span class="s2">    &quot;&quot;&quot;</span>

    <span class="ss">metanodes =</span> list<span class="p">(</span>metapath<span class="o">.</span>get_nodes<span class="p">())</span>

    <span class="ss">freq =</span> collections<span class="o">.</span>Counter<span class="p">(</span>metanodes<span class="p">)</span>

    <span class="ss">repeated =</span> <span class="p">{</span>metanode for metanode<span class="p">,</span> count <span class="k">in</span> freq<span class="o">.</span>items<span class="p">()</span> <span class="k">if</span> count <span class="err">&gt;</span> <span class="mi">1</span><span class="p">}</span>

    <span class="k">if</span> not repeated<span class="p">:</span>

        return <span class="err">&#39;</span>no_repeats&#39;

    <span class="ss">repeats_only =</span> <span class="p">[</span>node for node <span class="k">in</span> metanodes <span class="k">if</span> node <span class="k">in</span> repeated<span class="p">]</span>

    <span class="c1"># Group neighbors if they are the same</span>

    <span class="ss">grouped =</span> <span class="p">[</span>list<span class="p">(</span>v<span class="p">)</span> for k<span class="p">,</span> v <span class="k">in</span> itertools<span class="o">.</span>groupby<span class="p">(</span>repeats_only<span class="p">)]</span>

    <span class="c1"># Handle multiple disjoint repeats, any number, ie. AA,BB,CC,DD,...</span>

    <span class="k">if</span> len<span class="p">(</span>grouped<span class="p">)</span> <span class="o">==</span> len<span class="p">(</span>repeated<span class="p">):</span>

        <span class="c1"># Identify if there is only one metanode</span>

        <span class="k">if</span> len<span class="p">(</span>repeated<span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

            <span class="k">if</span> max<span class="p">(</span>freq<span class="o">.</span>values<span class="p">())</span> <span class="err">&lt;</span> <span class="mi">4</span><span class="p">:</span>

                return <span class="err">&#39;</span>short_repeat&#39;

            elif max<span class="p">(</span>freq<span class="o">.</span>values<span class="p">())</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>

                return <span class="err">&#39;</span>four_repeat&#39;

            <span class="k">else</span><span class="p">:</span>

                return <span class="err">&#39;</span>long_repeat&#39;

        return <span class="err">&#39;</span>disjoint&#39;

    <span class="k">assert</span> len<span class="p">(</span>repeats_only<span class="p">)</span> <span class="err">&gt;</span> <span class="mi">3</span>

    <span class="c1"># Categorize the reformatted metapath</span>

    <span class="k">if</span> len<span class="p">(</span>repeats_only<span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>

        <span class="k">if</span> repeats_only<span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> repeats_only<span class="p">[</span><span class="err">-</span><span class="mi">1</span><span class="p">]:</span>

            <span class="k">assert</span> repeats_only<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> repeats_only<span class="p">[</span><span class="mi">2</span><span class="p">]</span>

            return <span class="err">&#39;</span>BAAB&#39;

        <span class="k">else</span><span class="p">:</span>

            <span class="k">assert</span> <span class="p">(</span>repeats_only<span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> repeats_only<span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">and</span>

                    repeats_only<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> repeats_only<span class="p">[</span><span class="mi">3</span><span class="p">])</span>

            return <span class="err">&#39;</span>BABA&#39;

    elif len<span class="p">(</span>repeats_only<span class="p">)</span> <span class="o">==</span> <span class="mi">5</span> <span class="ow">and</span> max<span class="p">(</span><span class="nb">map</span><span class="p">(</span>len<span class="p">,</span> grouped<span class="p">))</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>

        <span class="k">if</span> repeats_only<span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> repeats_only<span class="p">[</span><span class="err">-</span><span class="mi">1</span><span class="p">]:</span>

            return <span class="err">&#39;</span>BAAB&#39;

    elif <span class="ss">repeats_only =</span><span class="o">=</span> list<span class="p">(</span>reversed<span class="p">(</span>repeats_only<span class="p">))</span> <span class="ow">and</span> <span class="err">\</span>

            not len<span class="p">(</span>repeats_only<span class="p">)</span> <span class="err">%</span> <span class="mi">2</span><span class="p">:</span>

        return <span class="err">&#39;</span>BAAB&#39;

    <span class="c1"># 6 node paths with 3x2 repeats</span>

    elif len<span class="p">(</span>repeated<span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> len<span class="p">(</span>metapath<span class="p">)</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>

        <span class="k">if</span> repeats_only<span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> repeats_only<span class="p">[</span><span class="err">-</span><span class="mi">1</span><span class="p">]:</span>

            return <span class="err">&#39;</span>repeat_around&#39;

        <span class="c1"># AABCCB or AABCBC</span>

        elif len<span class="p">(</span>grouped<span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">or</span> len<span class="p">(</span>grouped<span class="p">[</span><span class="err">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>

            return <span class="err">&#39;</span>disjoint_groups&#39;

        <span class="c1"># ABA CC B</span>

        elif len<span class="p">(</span>repeats_only<span class="p">)</span> <span class="err">-</span> len<span class="p">(</span>grouped<span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

            return <span class="err">&#39;</span>interior_complete_group&#39;

        <span class="c1"># most complicated len 6</span>

        <span class="k">else</span><span class="p">:</span>

            return <span class="err">&#39;</span>other&#39;

    <span class="k">else</span><span class="p">:</span>

        <span class="c1"># Multi-repeats that aren&#39;t disjoint, eg. ABCBAC</span>

        <span class="k">if</span> len<span class="p">(</span>repeated<span class="p">)</span> <span class="err">&gt;</span> <span class="mi">2</span><span class="p">:</span>

            logging<span class="o">.</span>info<span class="p">(</span>

                f<span class="s2">&quot;{metapath}: Only two overlapping repeats currently supported&quot;</span>

            <span class="p">)</span>

            return <span class="err">&#39;</span>other&#39;

        <span class="k">if</span> len<span class="p">(</span>metanodes<span class="p">)</span> <span class="err">&gt;</span> <span class="mi">4</span><span class="p">:</span>

            logging<span class="o">.</span>info<span class="p">(</span>

                f<span class="s2">&quot;{metapath}: Complex metapaths of length &gt; 4 are not yet &quot;</span>

                f<span class="s2">&quot;supported&quot;</span><span class="p">)</span>

            return <span class="err">&#39;</span>other&#39;

        <span class="k">assert</span> False
</code></pre></div>


</details>
<h3 id="default_dwwc_method">default_dwwc_method</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">default_dwwc_method</span><span class="p">(</span>
    <span class="n">graph</span><span class="p">,</span>
    <span class="n">metapath</span><span class="p">,</span>
    <span class="n">damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
    <span class="n">dense_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">dtype</span><span class="o">=&lt;</span><span class="k">class</span> <span class="err">&#39;</span><span class="nc">numpy</span><span class="o">.</span><span class="n">float64</span><span class="s1">&#39;&gt;</span>
<span class="p">)</span>
</code></pre></div>


<p>Uses optimal matrix chain multiplication as in numpy.multi_dot, but allows
for sparse matrices. Uses ordering modified from numpy.linalg.linalg._multi_dot
(https://git.io/vh31f) which is released under a 3-Clause BSD License
(https://git.io/vhCDC).</p>
<details class="example"><summary>View Source</summary><div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">dwwc_chain</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="p">.</span><span class="n">float64</span><span class="p">):</span>

    <span class="ss">&quot;&quot;&quot;</span>

<span class="ss">    Uses optimal matrix chain multiplication as in numpy.multi_dot, but allows</span>

<span class="ss">    for sparse matrices. Uses ordering modified from numpy.linalg.linalg._multi_dot</span>

<span class="ss">    (https://git.io/vh31f) which is released under a 3-Clause BSD License</span>

<span class="ss">    (https://git.io/vhCDC).</span>

<span class="ss">    &quot;&quot;&quot;</span>

    <span class="n">metapath</span> <span class="o">=</span> <span class="n">graph</span><span class="p">.</span><span class="n">metagraph</span><span class="p">.</span><span class="n">get_metapath</span><span class="p">(</span><span class="n">metapath</span><span class="p">)</span>

    <span class="n">array_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">graph</span><span class="p">.</span><span class="n">count_nodes</span><span class="p">(</span><span class="n">mn</span><span class="p">)</span> <span class="k">for</span> <span class="n">mn</span> <span class="k">in</span> <span class="n">metapath</span><span class="p">.</span><span class="n">get_nodes</span><span class="p">()]</span>

    <span class="n">row_ids</span> <span class="o">=</span> <span class="n">hetmatpy</span><span class="p">.</span><span class="n">matrix</span><span class="p">.</span><span class="n">get_node_identifiers</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">.</span><span class="k">source</span><span class="p">())</span>

    <span class="n">columns_ids</span> <span class="o">=</span> <span class="n">hetmatpy</span><span class="p">.</span><span class="n">matrix</span><span class="p">.</span><span class="n">get_node_identifiers</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">.</span><span class="n">target</span><span class="p">())</span>

    <span class="n">ordering</span> <span class="o">=</span> <span class="n">_dimensions_to_ordering</span><span class="p">(</span><span class="n">array_dims</span><span class="p">)</span>

    <span class="n">dwwc_matrix</span> <span class="o">=</span> <span class="n">_multi_dot</span><span class="p">(</span><span class="n">metapath</span><span class="p">,</span> <span class="n">ordering</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">(</span><span class="n">metapath</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">damping</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>

    <span class="n">dwwc_matrix</span> <span class="o">=</span> <span class="n">sparsify_or_densify</span><span class="p">(</span><span class="n">dwwc_matrix</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">row_ids</span><span class="p">,</span> <span class="n">columns_ids</span><span class="p">,</span> <span class="n">dwwc_matrix</span>
</code></pre></div>


</details>
<h3 id="dwpc">dwpc</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">dwpc</span><span class="p">(</span>
    <span class="n">graph</span><span class="p">,</span>
    <span class="n">metapath</span><span class="p">,</span>
    <span class="n">damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
    <span class="n">dense_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">approx_ok</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">dtype</span><span class="o">=&lt;</span><span class="k">class</span> <span class="err">&#39;</span><span class="nc">numpy</span><span class="o">.</span><span class="n">float64</span><span class="s1">&#39;&gt;,</span>
    <span class="n">dwwc_method</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
</code></pre></div>


<p>A unified function to compute the degree-weighted path count.
This function will call get_segments, then the appropriate
specialized (or generalized) DWPC function.</p>
<h2 id="parameters_1">Parameters</h2>
<p>graph : hetnetpy.hetnet.Graph
metapath : hetnetpy.hetnet.MetaPath
damping : float
dense_threshold : float (0 &lt;= dense_threshold &lt;= 1)
    sets the density threshold above which a sparse matrix will be
    converted to a dense automatically.
approx_ok : bool
    if True, uses an approximation to DWPC. If False, dwpc will call
    _dwpc_general_case and give a warning on metapaths which are
    categorized 'other' and 'long_repeat'..
dtype : dtype object
    numpy.float32 or numpy.float64. At present, numpy.float16 fails when
    using sparse matrices, due to a bug in scipy.sparse
dwwc_method : function
    dwwc method to use for computing DWWCs. If set to None, use
    module-level default (default_dwwc_method).</p>
<h2 id="returns_1">Returns</h2>
<p>numpy.ndarray
    row labels
numpy.ndarray
    column labels
numpy.ndarray or scipy.sparse.csc_matrix
    the DWPC matrix</p>
<details class="example"><summary>View Source</summary><div class="codehilite"><pre><span></span><code><span class="nv">@path_count_cache</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="s1">&#39;dwpc&#39;</span><span class="p">)</span><span class="w"></span>

<span class="n">def</span><span class="w"> </span><span class="n">dwpc</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span><span class="w"> </span><span class="n">metapath</span><span class="p">,</span><span class="w"> </span><span class="n">damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="n">dense_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">approx_ok</span><span class="o">=</span><span class="k">False</span><span class="p">,</span><span class="w"></span>

<span class="w">         </span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="p">.</span><span class="n">float64</span><span class="p">,</span><span class="w"> </span><span class="n">dwwc_method</span><span class="o">=</span><span class="k">None</span><span class="p">)</span><span class="err">:</span><span class="w"></span>

<span class="w">    </span><span class="ss">&quot;&quot;&quot;</span>

<span class="ss">    A unified function to compute the degree-weighted path count.</span>

<span class="ss">    This function will call get_segments, then the appropriate</span>

<span class="ss">    specialized (or generalized) DWPC function.</span>

<span class="ss">    Parameters</span>

<span class="ss">    ----------</span>

<span class="ss">    graph : hetnetpy.hetnet.Graph</span>

<span class="ss">    metapath : hetnetpy.hetnet.MetaPath</span>

<span class="ss">    damping : float</span>

<span class="ss">    dense_threshold : float (0 &lt;= dense_threshold &lt;= 1)</span>

<span class="ss">        sets the density threshold above which a sparse matrix will be</span>

<span class="ss">        converted to a dense automatically.</span>

<span class="ss">    approx_ok : bool</span>

<span class="ss">        if True, uses an approximation to DWPC. If False, dwpc will call</span>

<span class="ss">        _dwpc_general_case and give a warning on metapaths which are</span>

<span class="ss">        categorized &#39;other&#39; and &#39;long_repeat&#39;..</span>

<span class="ss">    dtype : dtype object</span>

<span class="ss">        numpy.float32 or numpy.float64. At present, numpy.float16 fails when</span>

<span class="ss">        using sparse matrices, due to a bug in scipy.sparse</span>

<span class="ss">    dwwc_method : function</span>

<span class="ss">        dwwc method to use for computing DWWCs. If set to None, use</span>

<span class="ss">        module-level default (default_dwwc_method).</span>

<span class="ss">    Returns</span>

<span class="ss">    -------</span>

<span class="ss">    numpy.ndarray</span>

<span class="ss">        row labels</span>

<span class="ss">    numpy.ndarray</span>

<span class="ss">        column labels</span>

<span class="ss">    numpy.ndarray or scipy.sparse.csc_matrix</span>

<span class="ss">        the DWPC matrix</span>

<span class="ss">    &quot;&quot;&quot;</span><span class="w"></span>

<span class="w">    </span><span class="n">category</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">categorize</span><span class="p">(</span><span class="n">metapath</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">dwpc_function</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_category_to_function</span><span class="p">(</span><span class="n">category</span><span class="p">,</span><span class="w"> </span><span class="n">dwwc_method</span><span class="o">=</span><span class="n">dwwc_method</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">category</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;long_repeat&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;other&#39;</span><span class="p">)</span><span class="err">:</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nl">approx_ok</span><span class="p">:</span><span class="w"></span>

<span class="w">            </span><span class="n">dwpc_function</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_dwpc_approx</span><span class="w"></span>

<span class="w">        </span><span class="k">else</span><span class="err">:</span><span class="w"></span>

<span class="w">            </span><span class="n">logging</span><span class="p">.</span><span class="n">warning</span><span class="p">(</span><span class="n">f</span><span class="ss">&quot;Metapath {metapath} will use _dwpc_general_case, &quot;</span><span class="w"></span>

<span class="w">                            </span><span class="ss">&quot;which can require very long computations.&quot;</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">row_names</span><span class="p">,</span><span class="w"> </span><span class="n">col_names</span><span class="p">,</span><span class="w"> </span><span class="n">dwpc_matrix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dwpc_function</span><span class="p">(</span><span class="w"></span>

<span class="w">        </span><span class="n">graph</span><span class="p">,</span><span class="w"> </span><span class="n">metapath</span><span class="p">,</span><span class="w"> </span><span class="n">damping</span><span class="p">,</span><span class="w"> </span><span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">row_names</span><span class="p">,</span><span class="w"> </span><span class="n">col_names</span><span class="p">,</span><span class="w"> </span><span class="n">dwpc_matrix</span><span class="w"></span>
</code></pre></div>


</details>
<h3 id="dwwc">dwwc</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">dwwc</span><span class="p">(</span>
    <span class="n">graph</span><span class="p">,</span>
    <span class="n">metapath</span><span class="p">,</span>
    <span class="n">damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
    <span class="n">dense_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">dtype</span><span class="o">=&lt;</span><span class="k">class</span> <span class="err">&#39;</span><span class="nc">numpy</span><span class="o">.</span><span class="n">float64</span><span class="s1">&#39;&gt;,</span>
    <span class="n">dwwc_method</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
</code></pre></div>


<p>Compute the degree-weighted walk count (DWWC) in which nodes can be
repeated within a path.</p>
<h2 id="parameters_2">Parameters</h2>
<p>graph : hetnetpy.hetnet.Graph
metapath : hetnetpy.hetnet.MetaPath
damping : float
dense_threshold : float (0 &lt;= dense_threshold &lt;= 1)
    sets the density threshold at which a sparse matrix will be
    converted to a dense automatically.
dtype : dtype object
dwwc_method : function
    dwwc method to use for computing DWWCs. If set to None, use
    module-level default (default_dwwc_method).</p>
<details class="example"><summary>View Source</summary><div class="codehilite"><pre><span></span><code><span class="nv">@path_count_cache</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="s1">&#39;dwwc&#39;</span><span class="p">)</span><span class="w"></span>

<span class="n">def</span><span class="w"> </span><span class="n">dwwc</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span><span class="w"> </span><span class="n">metapath</span><span class="p">,</span><span class="w"> </span><span class="n">damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="n">dense_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="p">.</span><span class="n">float64</span><span class="p">,</span><span class="w"> </span><span class="n">dwwc_method</span><span class="o">=</span><span class="k">None</span><span class="p">)</span><span class="err">:</span><span class="w"></span>

<span class="w">    </span><span class="ss">&quot;&quot;&quot;</span>

<span class="ss">    Compute the degree-weighted walk count (DWWC) in which nodes can be</span>

<span class="ss">    repeated within a path.</span>

<span class="ss">    Parameters</span>

<span class="ss">    ----------</span>

<span class="ss">    graph : hetnetpy.hetnet.Graph</span>

<span class="ss">    metapath : hetnetpy.hetnet.MetaPath</span>

<span class="ss">    damping : float</span>

<span class="ss">    dense_threshold : float (0 &lt;= dense_threshold &lt;= 1)</span>

<span class="ss">        sets the density threshold at which a sparse matrix will be</span>

<span class="ss">        converted to a dense automatically.</span>

<span class="ss">    dtype : dtype object</span>

<span class="ss">    dwwc_method : function</span>

<span class="ss">        dwwc method to use for computing DWWCs. If set to None, use</span>

<span class="ss">        module-level default (default_dwwc_method).</span>

<span class="ss">    &quot;&quot;&quot;</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">dwwc_method</span><span class="p">(</span><span class="w"></span>

<span class="w">        </span><span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="n">metapath</span><span class="o">=</span><span class="n">metapath</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="w"></span>

<span class="w">    </span><span class="p">)</span><span class="w"></span>
</code></pre></div>


</details>
<h3 id="dwwc_chain">dwwc_chain</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">dwwc_chain</span><span class="p">(</span>
    <span class="n">graph</span><span class="p">,</span>
    <span class="n">metapath</span><span class="p">,</span>
    <span class="n">damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
    <span class="n">dense_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">dtype</span><span class="o">=&lt;</span><span class="k">class</span> <span class="err">&#39;</span><span class="nc">numpy</span><span class="o">.</span><span class="n">float64</span><span class="s1">&#39;&gt;</span>
<span class="p">)</span>
</code></pre></div>


<p>Uses optimal matrix chain multiplication as in numpy.multi_dot, but allows
for sparse matrices. Uses ordering modified from numpy.linalg.linalg._multi_dot
(https://git.io/vh31f) which is released under a 3-Clause BSD License
(https://git.io/vhCDC).</p>
<details class="example"><summary>View Source</summary><div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">dwwc_chain</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="p">.</span><span class="n">float64</span><span class="p">):</span>

    <span class="ss">&quot;&quot;&quot;</span>

<span class="ss">    Uses optimal matrix chain multiplication as in numpy.multi_dot, but allows</span>

<span class="ss">    for sparse matrices. Uses ordering modified from numpy.linalg.linalg._multi_dot</span>

<span class="ss">    (https://git.io/vh31f) which is released under a 3-Clause BSD License</span>

<span class="ss">    (https://git.io/vhCDC).</span>

<span class="ss">    &quot;&quot;&quot;</span>

    <span class="n">metapath</span> <span class="o">=</span> <span class="n">graph</span><span class="p">.</span><span class="n">metagraph</span><span class="p">.</span><span class="n">get_metapath</span><span class="p">(</span><span class="n">metapath</span><span class="p">)</span>

    <span class="n">array_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">graph</span><span class="p">.</span><span class="n">count_nodes</span><span class="p">(</span><span class="n">mn</span><span class="p">)</span> <span class="k">for</span> <span class="n">mn</span> <span class="k">in</span> <span class="n">metapath</span><span class="p">.</span><span class="n">get_nodes</span><span class="p">()]</span>

    <span class="n">row_ids</span> <span class="o">=</span> <span class="n">hetmatpy</span><span class="p">.</span><span class="n">matrix</span><span class="p">.</span><span class="n">get_node_identifiers</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">.</span><span class="k">source</span><span class="p">())</span>

    <span class="n">columns_ids</span> <span class="o">=</span> <span class="n">hetmatpy</span><span class="p">.</span><span class="n">matrix</span><span class="p">.</span><span class="n">get_node_identifiers</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">.</span><span class="n">target</span><span class="p">())</span>

    <span class="n">ordering</span> <span class="o">=</span> <span class="n">_dimensions_to_ordering</span><span class="p">(</span><span class="n">array_dims</span><span class="p">)</span>

    <span class="n">dwwc_matrix</span> <span class="o">=</span> <span class="n">_multi_dot</span><span class="p">(</span><span class="n">metapath</span><span class="p">,</span> <span class="n">ordering</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">(</span><span class="n">metapath</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">damping</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>

    <span class="n">dwwc_matrix</span> <span class="o">=</span> <span class="n">sparsify_or_densify</span><span class="p">(</span><span class="n">dwwc_matrix</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">row_ids</span><span class="p">,</span> <span class="n">columns_ids</span><span class="p">,</span> <span class="n">dwwc_matrix</span>
</code></pre></div>


</details>
<h3 id="dwwc_recursive">dwwc_recursive</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">dwwc_recursive</span><span class="p">(</span>
    <span class="n">graph</span><span class="p">,</span>
    <span class="n">metapath</span><span class="p">,</span>
    <span class="n">damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
    <span class="n">dense_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">dtype</span><span class="o">=&lt;</span><span class="k">class</span> <span class="err">&#39;</span><span class="nc">numpy</span><span class="o">.</span><span class="n">float64</span><span class="s1">&#39;&gt;</span>
<span class="p">)</span>
</code></pre></div>


<p>Recursive DWWC implementation to take better advantage of caching.</p>
<details class="example"><summary>View Source</summary><div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">dwwc_recursive</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="p">.</span><span class="n">float64</span><span class="p">):</span>

    <span class="ss">&quot;&quot;&quot;</span>

<span class="ss">    Recursive DWWC implementation to take better advantage of caching.</span>

<span class="ss">    &quot;&quot;&quot;</span>

    <span class="k">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">adj_mat</span> <span class="o">=</span> <span class="n">hetmatpy</span><span class="p">.</span><span class="n">matrix</span><span class="p">.</span><span class="n">metaedge_to_adjacency_matrix</span><span class="p">(</span>

        <span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">adj_mat</span> <span class="o">=</span> <span class="n">_degree_weight</span><span class="p">(</span><span class="n">adj_mat</span><span class="p">,</span> <span class="n">damping</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">len</span><span class="p">(</span><span class="n">metapath</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">dwwc_next</span> <span class="o">=</span> <span class="n">dwwc</span><span class="p">(</span>

            <span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span>

            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">dwwc_method</span><span class="o">=</span><span class="n">dwwc_recursive</span><span class="p">)</span>

        <span class="n">dwwc_matrix</span> <span class="o">=</span> <span class="n">adj_mat</span> <span class="o">@</span> <span class="n">dwwc_next</span>

    <span class="k">else</span><span class="p">:</span>

        <span class="n">dwwc_matrix</span> <span class="o">=</span> <span class="n">adj_mat</span>

    <span class="n">dwwc_matrix</span> <span class="o">=</span> <span class="n">sparsify_or_densify</span><span class="p">(</span><span class="n">dwwc_matrix</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="p">)</span>

    <span class="k">return</span> <span class="k">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">dwwc_matrix</span>
</code></pre></div>


</details>
<h3 id="dwwc_sequential">dwwc_sequential</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">dwwc_sequential</span><span class="p">(</span>
    <span class="n">graph</span><span class="p">,</span>
    <span class="n">metapath</span><span class="p">,</span>
    <span class="n">damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
    <span class="n">dense_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">dtype</span><span class="o">=&lt;</span><span class="k">class</span> <span class="err">&#39;</span><span class="nc">numpy</span><span class="o">.</span><span class="n">float64</span><span class="s1">&#39;&gt;</span>
<span class="p">)</span>
</code></pre></div>


<p>Compute the degree-weighted walk count (DWWC) in which nodes can be
repeated within a path.</p>
<h2 id="parameters_3">Parameters</h2>
<p>graph : hetnetpy.hetnet.Graph
metapath : hetnetpy.hetnet.MetaPath
damping : float
dense_threshold : float (0 &lt;= dense_threshold &lt;= 1)
    sets the density threshold at which a sparse matrix will be
    converted to a dense automatically.
dtype : dtype object</p>
<details class="example"><summary>View Source</summary><div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">dwwc_sequential</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="p">.</span><span class="n">float64</span><span class="p">):</span>

    <span class="ss">&quot;&quot;&quot;</span>

<span class="ss">    Compute the degree-weighted walk count (DWWC) in which nodes can be</span>

<span class="ss">    repeated within a path.</span>

<span class="ss">    Parameters</span>

<span class="ss">    ----------</span>

<span class="ss">    graph : hetnetpy.hetnet.Graph</span>

<span class="ss">    metapath : hetnetpy.hetnet.MetaPath</span>

<span class="ss">    damping : float</span>

<span class="ss">    dense_threshold : float (0 &lt;= dense_threshold &lt;= 1)</span>

<span class="ss">        sets the density threshold at which a sparse matrix will be</span>

<span class="ss">        converted to a dense automatically.</span>

<span class="ss">    dtype : dtype object</span>

<span class="ss">    &quot;&quot;&quot;</span>

    <span class="n">dwwc_matrix</span> <span class="o">=</span> <span class="k">None</span>

    <span class="n">row_names</span> <span class="o">=</span> <span class="k">None</span>

    <span class="k">for</span> <span class="n">metaedge</span> <span class="k">in</span> <span class="n">metapath</span><span class="p">:</span>

        <span class="k">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">adj_mat</span> <span class="o">=</span> <span class="n">hetmatpy</span><span class="p">.</span><span class="n">matrix</span><span class="p">.</span><span class="n">metaedge_to_adjacency_matrix</span><span class="p">(</span>

            <span class="n">graph</span><span class="p">,</span> <span class="n">metaedge</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">adj_mat</span> <span class="o">=</span> <span class="n">_degree_weight</span><span class="p">(</span><span class="n">adj_mat</span><span class="p">,</span> <span class="n">damping</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dwwc_matrix</span> <span class="k">is</span> <span class="k">None</span><span class="p">:</span>

            <span class="n">row_names</span> <span class="o">=</span> <span class="k">rows</span>

            <span class="n">dwwc_matrix</span> <span class="o">=</span> <span class="n">adj_mat</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="n">dwwc_matrix</span> <span class="o">=</span> <span class="n">dwwc_matrix</span> <span class="o">@</span> <span class="n">adj_mat</span>

            <span class="n">dwwc_matrix</span> <span class="o">=</span> <span class="n">sparsify_or_densify</span><span class="p">(</span><span class="n">dwwc_matrix</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">row_names</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">dwwc_matrix</span>
</code></pre></div>


</details>
<h3 id="get_all_segments">get_all_segments</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">get_all_segments</span><span class="p">(</span>
    <span class="n">metagraph</span><span class="p">,</span>
    <span class="n">metapath</span>
<span class="p">)</span>
</code></pre></div>


<p>Return all subsegments of a given metapath, including those segments that
appear only after early splits.</p>
<h2 id="parameters_4">Parameters</h2>
<p>metagraph : hetnetpy.hetnet.MetaGraph
metapath : hetnetpy.hetnet.MetaPath</p>
<h2 id="returns_2">Returns</h2>
<p>list</p>
<h2 id="example">Example</h2>
<blockquote>
<blockquote>
<blockquote>
<p>get_all_segments(metagraph, CrCbGaDrDaG)
[CrC, CbG, GaDrDaG, GaD, DrD, DaG]</p>
</blockquote>
</blockquote>
</blockquote>
<details class="example"><summary>View Source</summary><div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">get_all_segments</span><span class="p">(</span><span class="n">metagraph</span><span class="p">,</span><span class="w"> </span><span class="n">metapath</span><span class="p">)</span><span class="err">:</span><span class="w"></span>

<span class="w">    </span><span class="ss">&quot;&quot;&quot;</span>

<span class="ss">    Return all subsegments of a given metapath, including those segments that</span>

<span class="ss">    appear only after early splits.</span>

<span class="ss">    Parameters</span>

<span class="ss">    ----------</span>

<span class="ss">    metagraph : hetnetpy.hetnet.MetaGraph</span>

<span class="ss">    metapath : hetnetpy.hetnet.MetaPath</span>

<span class="ss">    Returns</span>

<span class="ss">    -------</span>

<span class="ss">    list</span>

<span class="ss">    Example</span>

<span class="ss">    -------</span>

<span class="ss">    &gt;&gt;&gt; get_all_segments(metagraph, CrCbGaDrDaG)</span>

<span class="ss">    [CrC, CbG, GaDrDaG, GaD, DrD, DaG]</span>

<span class="ss">    &quot;&quot;&quot;</span><span class="w"></span>

<span class="w">    </span><span class="n">metapath</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">metagraph</span><span class="p">.</span><span class="n">get_metapath</span><span class="p">(</span><span class="n">metapath</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">segments</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_segments</span><span class="p">(</span><span class="n">metagraph</span><span class="p">,</span><span class="w"> </span><span class="n">metapath</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nf">len</span><span class="p">(</span><span class="n">segments</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="err">:</span><span class="w"></span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">[</span><span class="n">metapath</span><span class="o">]</span><span class="w"></span>

<span class="w">    </span><span class="n">all_subsegments</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="n">metapath</span><span class="o">]</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">segment</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nl">segments</span><span class="p">:</span><span class="w"></span>

<span class="w">        </span><span class="n">subsegments</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_all_segments</span><span class="p">(</span><span class="n">metagraph</span><span class="p">,</span><span class="w"> </span><span class="n">segment</span><span class="p">)</span><span class="w"></span>

<span class="w">        </span><span class="n">next_split</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">subsegments</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nf">len</span><span class="p">(</span><span class="n">subsegments</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="err">[]</span><span class="w"></span>

<span class="w">        </span><span class="n">all_subsegments</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">all_subsegments</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">[</span><span class="n">segment</span><span class="o">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">next_split</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">all_subsegments</span><span class="w"></span>
</code></pre></div>


</details>
<h3 id="get_segments">get_segments</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">get_segments</span><span class="p">(</span>
    <span class="n">metagraph</span><span class="p">,</span>
    <span class="n">metapath</span>
<span class="p">)</span>
</code></pre></div>


<p>Split a metapath into segments of recognized groups and non-repeated
nodes. Groups include BAAB, BABA, disjoint short- and long-repeats.
Returns an error for categorization 'other'.</p>
<h2 id="parameters_5">Parameters</h2>
<p>metagraph : hetnetpy.hetnet.MetaGraph
metapath : hetnetpy.hetnet.Metapath</p>
<h2 id="returns_3">Returns</h2>
<p>list
    list of metapaths. If the metapath is not segmentable or is already
    fully simplified (eg. GiGaDaG), then the list will have only one
    element.</p>
<h2 id="examples">Examples</h2>
<p>'CbGaDaGaD' -&gt; ['CbG', 'GaD', 'GaG', 'GaD']
'GbCpDaGaD' -&gt; ['GbCpD', 'DaG', 'GaD']
'CrCbGiGaDrD' -&gt; ['CrC', 'CbG', 'GiG', 'GaD', 'DrD']</p>
<details class="example"><summary>View Source</summary><div class="codehilite"><pre><span></span><code><span class="s s-Atom">def</span> <span class="nf">get_segments</span><span class="p">(</span><span class="s s-Atom">metagraph</span><span class="p">,</span> <span class="s s-Atom">metapath</span><span class="p">)</span><span class="s s-Atom">:</span>

    <span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    Split a metapath into segments of recognized groups and non-repeated</span>

<span class="s2">    nodes. Groups include BAAB, BABA, disjoint short- and long-repeats.</span>

<span class="s2">    Returns an error for categorization &#39;other&#39;.</span>

<span class="s2">    Parameters</span>

<span class="s2">    ----------</span>

<span class="s2">    metagraph : hetnetpy.hetnet.MetaGraph</span>

<span class="s2">    metapath : hetnetpy.hetnet.Metapath</span>

<span class="s2">    Returns</span>

<span class="s2">    -------</span>

<span class="s2">    list</span>

<span class="s2">        list of metapaths. If the metapath is not segmentable or is already</span>

<span class="s2">        fully simplified (eg. GiGaDaG), then the list will have only one</span>

<span class="s2">        element.</span>

<span class="s2">    Examples</span>

<span class="s2">    --------</span>

<span class="s2">    &#39;CbGaDaGaD&#39; -&gt; [&#39;CbG&#39;, &#39;GaD&#39;, &#39;GaG&#39;, &#39;GaD&#39;]</span>

<span class="s2">    &#39;GbCpDaGaD&#39; -&gt; [&#39;GbCpD&#39;, &#39;DaG&#39;, &#39;GaD&#39;]</span>

<span class="s2">    &#39;CrCbGiGaDrD&#39; -&gt; [&#39;CrC&#39;, &#39;CbG&#39;, &#39;GiG&#39;, &#39;GaD&#39;, &#39;DrD&#39;]</span>

<span class="s2">    &quot;&quot;&quot;</span>

    <span class="s s-Atom">def</span> <span class="nf">add_head_tail</span><span class="p">(</span><span class="s s-Atom">metapath</span><span class="p">,</span> <span class="s s-Atom">indices</span><span class="p">)</span><span class="s s-Atom">:</span>

        <span class="s2">&quot;&quot;&quot;Makes sure that all metanodes are included in segments.</span>

<span class="s2">        Ensures that the first segment goes all the way back to the</span>

<span class="s2">        first metanode. Similarly, makes sure that the last segment</span>

<span class="s2">        includes all metanodes up to the last one.&quot;&quot;&quot;</span>

        <span class="s s-Atom">#</span> <span class="s s-Atom">handle</span> <span class="s s-Atom">non</span><span class="o">-</span><span class="s s-Atom">duplicated</span> <span class="s s-Atom">on</span> <span class="s s-Atom">the</span> <span class="s s-Atom">front</span>

        <span class="s s-Atom">if</span> <span class="s s-Atom">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">!</span><span class="o">=</span> <span class="mi">0</span><span class="s s-Atom">:</span>

            <span class="s s-Atom">indices</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="s s-Atom">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])]</span> <span class="o">+</span> <span class="s s-Atom">indices</span>

        <span class="s s-Atom">#</span> <span class="s s-Atom">handle</span> <span class="s s-Atom">non</span><span class="o">-</span><span class="s s-Atom">duplicated</span> <span class="s s-Atom">on</span> <span class="s s-Atom">the</span> <span class="s s-Atom">end</span>

        <span class="s s-Atom">if</span> <span class="s s-Atom">indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">!</span><span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="s s-Atom">metapath</span><span class="p">)</span><span class="s s-Atom">:</span>

            <span class="s s-Atom">indices</span> <span class="o">=</span> <span class="s s-Atom">indices</span> <span class="o">+</span> <span class="p">[(</span><span class="s s-Atom">indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nf">len</span><span class="p">(</span><span class="s s-Atom">metapath</span><span class="p">))]</span>

        <span class="s s-Atom">return</span> <span class="s s-Atom">indices</span>

    <span class="s s-Atom">metapath</span> <span class="o">=</span> <span class="s s-Atom">metagraph</span><span class="p">.</span><span class="nf">get_metapath</span><span class="p">(</span><span class="s s-Atom">metapath</span><span class="p">)</span>

    <span class="s s-Atom">category</span> <span class="o">=</span> <span class="nf">categorize</span><span class="p">(</span><span class="s s-Atom">metapath</span><span class="p">)</span>

    <span class="s s-Atom">metanodes</span> <span class="o">=</span> <span class="s s-Atom">metapath</span><span class="p">.</span><span class="nf">get_nodes</span><span class="p">()</span>

    <span class="s s-Atom">freq</span> <span class="o">=</span> <span class="s s-Atom">collections</span><span class="p">.</span><span class="nv">Counter</span><span class="p">(</span><span class="s s-Atom">metanodes</span><span class="p">)</span>

    <span class="s s-Atom">repeated</span> <span class="o">=</span> <span class="p">{</span><span class="s s-Atom">i</span> <span class="s s-Atom">for</span> <span class="s s-Atom">i</span> <span class="s s-Atom">in</span> <span class="s s-Atom">freq</span><span class="p">.</span><span class="nf">keys</span><span class="p">()</span> <span class="s s-Atom">if</span> <span class="s s-Atom">freq</span><span class="p">[</span><span class="s s-Atom">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">}</span>

    <span class="s s-Atom">if</span> <span class="s s-Atom">category</span> <span class="o">==</span> <span class="s s-Atom">&#39;no_repeats&#39;:</span>

        <span class="s s-Atom">return</span> <span class="p">[</span><span class="s s-Atom">metapath</span><span class="p">]</span>

    <span class="s s-Atom">elif</span> <span class="s s-Atom">category</span> <span class="o">==</span> <span class="s s-Atom">&#39;repeat_around&#39;:</span>

        <span class="s s-Atom">#</span> <span class="nv">Note</span> <span class="s s-Atom">this</span> <span class="o">is</span> <span class="s s-Atom">hard</span><span class="o">-</span><span class="s s-Atom">coded</span> <span class="s s-Atom">and</span> <span class="s s-Atom">will</span> <span class="s s-Atom">need</span> <span class="s s-Atom">to</span> <span class="s s-Atom">be</span> <span class="s s-Atom">updated</span> <span class="s s-Atom">for</span> <span class="s s-Atom">various</span>

        <span class="s s-Atom">#</span> <span class="s s-Atom">metapath</span> <span class="s s-Atom">lengths</span>

        <span class="s s-Atom">indices</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]]</span>

    <span class="s s-Atom">elif</span> <span class="s s-Atom">category</span> <span class="o">==</span> <span class="s s-Atom">&#39;disjoint_groups&#39;:</span>

        <span class="s s-Atom">#</span> <span class="nv">CCBABA</span> <span class="s s-Atom">or</span> <span class="nv">CCBAAB</span> <span class="s s-Atom">or</span> <span class="nv">BABACC</span> <span class="s s-Atom">or</span> <span class="nv">BAABCC</span> <span class="s s-Atom">-&gt;</span> <span class="p">[</span><span class="nv">CC</span><span class="p">,</span> <span class="nv">BABA</span><span class="p">],</span> <span class="s s-Atom">etc</span><span class="p">.</span>

        <span class="s s-Atom">metanodes</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="s s-Atom">metapath</span><span class="p">.</span><span class="nf">get_nodes</span><span class="p">())</span>

        <span class="s s-Atom">grouped</span> <span class="o">=</span> <span class="p">[</span><span class="nf">list</span><span class="p">(</span><span class="s s-Atom">v</span><span class="p">)</span> <span class="s s-Atom">for</span> <span class="s s-Atom">k</span><span class="p">,</span> <span class="s s-Atom">v</span> <span class="s s-Atom">in</span> <span class="s s-Atom">itertools</span><span class="p">.</span><span class="nf">groupby</span><span class="p">(</span><span class="s s-Atom">metanodes</span><span class="p">)]</span>

        <span class="s s-Atom">indices</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">]]</span> <span class="s s-Atom">if</span> <span class="nf">len</span><span class="p">(</span><span class="s s-Atom">grouped</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span> <span class="s s-Atom">else</span> <span class="p">[</span>

            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]]</span>

    <span class="s s-Atom">elif</span> <span class="s s-Atom">category</span> <span class="nf">in</span> <span class="p">(</span><span class="s s-Atom">&#39;disjoint&#39;</span><span class="p">,</span> <span class="s s-Atom">&#39;short_repeat&#39;</span><span class="p">,</span> <span class="s s-Atom">&#39;long_repeat&#39;</span><span class="p">)</span><span class="s s-Atom">:</span>

        <span class="s s-Atom">indices</span> <span class="o">=</span> <span class="nf">sorted</span><span class="p">([[</span><span class="s s-Atom">metanodes</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="s s-Atom">i</span><span class="p">),</span> <span class="nf">len</span><span class="p">(</span><span class="s s-Atom">metapath</span><span class="p">)</span> <span class="o">-</span> <span class="nf">list</span><span class="p">(</span>

            <span class="nf">reversed</span><span class="p">(</span><span class="s s-Atom">metanodes</span><span class="p">)).</span><span class="nf">index</span><span class="p">(</span><span class="s s-Atom">i</span><span class="p">)]</span> <span class="s s-Atom">for</span> <span class="s s-Atom">i</span> <span class="s s-Atom">in</span> <span class="s s-Atom">repeated</span><span class="p">])</span>

        <span class="s s-Atom">indices</span> <span class="o">=</span> <span class="nf">add_head_tail</span><span class="p">(</span><span class="s s-Atom">metapath</span><span class="p">,</span> <span class="s s-Atom">indices</span><span class="p">)</span>

        <span class="s s-Atom">#</span> <span class="s s-Atom">handle</span> <span class="s s-Atom">middle</span> <span class="s s-Atom">cases</span> <span class="s s-Atom">with</span> <span class="s s-Atom">non</span><span class="o">-</span><span class="s s-Atom">repeated</span> <span class="s s-Atom">nodes</span> <span class="s s-Atom">between</span> <span class="s s-Atom">disjoint</span> <span class="s s-Atom">regions</span>

        <span class="s s-Atom">#</span> <span class="nv">Eg</span><span class="p">.</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span> <span class="s s-Atom">-&gt;</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>

        <span class="s s-Atom">inds</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="s s-Atom">for</span> <span class="s s-Atom">i</span><span class="p">,</span> <span class="s s-Atom">v</span> <span class="s s-Atom">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="s s-Atom">indices</span><span class="p">[:-</span><span class="mi">1</span><span class="p">])</span><span class="s s-Atom">:</span>

            <span class="s s-Atom">inds</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="s s-Atom">v</span><span class="p">)</span>

            <span class="s s-Atom">if</span> <span class="s s-Atom">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">!</span><span class="o">=</span> <span class="s s-Atom">indices</span><span class="p">[</span><span class="s s-Atom">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="s s-Atom">:</span>

                <span class="s s-Atom">inds</span><span class="p">.</span><span class="nf">append</span><span class="p">([</span><span class="s s-Atom">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s s-Atom">indices</span><span class="p">[</span><span class="s s-Atom">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>

        <span class="s s-Atom">indices</span> <span class="o">=</span> <span class="s s-Atom">inds</span> <span class="o">+</span> <span class="p">[</span><span class="s s-Atom">indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

    <span class="s s-Atom">elif</span> <span class="s s-Atom">category</span> <span class="o">==</span> <span class="s s-Atom">&#39;four_repeat&#39;:</span>

        <span class="s s-Atom">nodes</span> <span class="o">=</span> <span class="nf">set</span><span class="p">(</span><span class="s s-Atom">metanodes</span><span class="p">)</span>

        <span class="s s-Atom">repeat_indices</span> <span class="o">=</span> <span class="p">(</span>

            <span class="p">[[</span><span class="s s-Atom">i</span> <span class="s s-Atom">for</span> <span class="s s-Atom">i</span><span class="p">,</span> <span class="s s-Atom">v</span> <span class="s s-Atom">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="s s-Atom">metanodes</span><span class="p">)</span>

              <span class="s s-Atom">if</span> <span class="s s-Atom">v</span> <span class="o">==</span> <span class="s s-Atom">metanode</span><span class="p">]</span> <span class="s s-Atom">for</span> <span class="s s-Atom">metanode</span> <span class="s s-Atom">in</span> <span class="s s-Atom">nodes</span><span class="p">])</span>

        <span class="s s-Atom">repeat_indices</span> <span class="o">=</span> <span class="p">[</span><span class="s s-Atom">i</span> <span class="s s-Atom">for</span> <span class="s s-Atom">i</span> <span class="s s-Atom">in</span> <span class="s s-Atom">repeat_indices</span> <span class="s s-Atom">if</span> <span class="nf">len</span><span class="p">(</span><span class="s s-Atom">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>

        <span class="s s-Atom">simple_repeats</span> <span class="o">=</span> <span class="p">[</span><span class="s s-Atom">i</span> <span class="s s-Atom">for</span> <span class="s s-Atom">group</span> <span class="s s-Atom">in</span> <span class="s s-Atom">repeat_indices</span> <span class="s s-Atom">for</span> <span class="s s-Atom">i</span> <span class="s s-Atom">in</span> <span class="s s-Atom">group</span><span class="p">]</span>

        <span class="s s-Atom">seconds</span> <span class="o">=</span> <span class="s s-Atom">simple_repeats</span><span class="p">[</span><span class="mi">1</span><span class="s s-Atom">:</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="s s-Atom">simple_repeats</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

        <span class="s s-Atom">indices</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">zip</span><span class="p">(</span><span class="s s-Atom">simple_repeats</span><span class="p">,</span> <span class="s s-Atom">seconds</span><span class="p">))</span>

        <span class="s s-Atom">indices</span> <span class="o">=</span> <span class="nf">add_head_tail</span><span class="p">(</span><span class="s s-Atom">metapath</span><span class="p">,</span> <span class="s s-Atom">indices</span><span class="p">)</span>

    <span class="s s-Atom">elif</span> <span class="s s-Atom">category</span> <span class="nf">in</span> <span class="p">(</span><span class="s s-Atom">&#39;BAAB&#39;</span><span class="p">,</span> <span class="s s-Atom">&#39;BABA&#39;</span><span class="p">,</span> <span class="s s-Atom">&#39;other&#39;</span><span class="p">,</span> <span class="s s-Atom">&#39;interior_complete_group&#39;</span><span class="p">)</span><span class="s s-Atom">:</span>

        <span class="s s-Atom">nodes</span> <span class="o">=</span> <span class="nf">set</span><span class="p">(</span><span class="s s-Atom">metanodes</span><span class="p">)</span>

        <span class="s s-Atom">repeat_indices</span> <span class="o">=</span> <span class="p">(</span>

            <span class="p">[[</span><span class="s s-Atom">i</span> <span class="s s-Atom">for</span> <span class="s s-Atom">i</span><span class="p">,</span> <span class="s s-Atom">v</span> <span class="s s-Atom">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="s s-Atom">metanodes</span><span class="p">)</span>

              <span class="s s-Atom">if</span> <span class="s s-Atom">v</span> <span class="o">==</span> <span class="s s-Atom">metanode</span><span class="p">]</span> <span class="s s-Atom">for</span> <span class="s s-Atom">metanode</span> <span class="s s-Atom">in</span> <span class="s s-Atom">nodes</span><span class="p">])</span>

        <span class="s s-Atom">repeat_indices</span> <span class="o">=</span> <span class="p">[</span><span class="s s-Atom">i</span> <span class="s s-Atom">for</span> <span class="s s-Atom">i</span> <span class="s s-Atom">in</span> <span class="s s-Atom">repeat_indices</span> <span class="s s-Atom">if</span> <span class="nf">len</span><span class="p">(</span><span class="s s-Atom">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>

        <span class="s s-Atom">simple_repeats</span> <span class="o">=</span> <span class="p">[</span><span class="s s-Atom">i</span> <span class="s s-Atom">for</span> <span class="s s-Atom">group</span> <span class="s s-Atom">in</span> <span class="s s-Atom">repeat_indices</span> <span class="s s-Atom">for</span> <span class="s s-Atom">i</span> <span class="s s-Atom">in</span> <span class="s s-Atom">group</span><span class="p">]</span>

        <span class="s s-Atom">inds</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="s s-Atom">for</span> <span class="s s-Atom">i</span> <span class="s s-Atom">in</span> <span class="s s-Atom">repeat_indices:</span>

            <span class="s s-Atom">if</span> <span class="nf">len</span><span class="p">(</span><span class="s s-Atom">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="s s-Atom">:</span>

                <span class="s s-Atom">inds</span> <span class="s s-Atom">+=</span> <span class="s s-Atom">i</span>

            <span class="s s-Atom">if</span> <span class="nf">len</span><span class="p">(</span><span class="s s-Atom">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="s s-Atom">:</span>

                <span class="s s-Atom">inds</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="s s-Atom">i</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                <span class="s s-Atom">inds</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="s s-Atom">i</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

                <span class="s s-Atom">for</span> <span class="s s-Atom">j</span> <span class="s s-Atom">in</span> <span class="s s-Atom">i</span><span class="p">[</span><span class="mi">1</span><span class="p">:-</span><span class="mi">1</span><span class="p">]</span><span class="s s-Atom">:</span>

                    <span class="nf">if</span> <span class="p">(</span><span class="s s-Atom">j</span> <span class="o">-</span> <span class="mi">1</span> <span class="s s-Atom">in</span> <span class="s s-Atom">simple_repeats</span> <span class="s s-Atom">and</span> <span class="s s-Atom">j</span> <span class="o">+</span> <span class="mi">1</span> <span class="s s-Atom">in</span> <span class="s s-Atom">simple_repeats</span><span class="p">)</span> <span class="s s-Atom">\</span>

                            <span class="s s-Atom">and</span> <span class="o">not</span> <span class="p">(</span><span class="s s-Atom">j</span> <span class="o">-</span> <span class="mi">1</span> <span class="s s-Atom">in</span> <span class="s s-Atom">i</span> <span class="s s-Atom">and</span> <span class="s s-Atom">j</span> <span class="o">+</span> <span class="mi">1</span> <span class="s s-Atom">in</span> <span class="s s-Atom">i</span><span class="p">)</span><span class="s s-Atom">:</span>

                        <span class="s s-Atom">inds</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="s s-Atom">j</span><span class="p">)</span>

        <span class="s s-Atom">inds</span> <span class="o">=</span> <span class="nf">sorted</span><span class="p">(</span><span class="s s-Atom">inds</span><span class="p">)</span>

        <span class="s s-Atom">seconds</span> <span class="o">=</span> <span class="s s-Atom">inds</span><span class="p">[</span><span class="mi">1</span><span class="s s-Atom">:</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="s s-Atom">inds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

        <span class="s s-Atom">indices</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">zip</span><span class="p">(</span><span class="s s-Atom">inds</span><span class="p">,</span> <span class="s s-Atom">seconds</span><span class="p">))</span>

        <span class="s s-Atom">indices</span> <span class="o">=</span> <span class="p">[</span><span class="s s-Atom">i</span> <span class="s s-Atom">for</span> <span class="s s-Atom">i</span> <span class="s s-Atom">in</span> <span class="s s-Atom">indices</span> <span class="s s-Atom">if</span> <span class="nf">len</span><span class="p">(</span><span class="nf">set</span><span class="p">(</span><span class="s s-Atom">i</span><span class="p">))</span> <span class="o">==</span> <span class="mi">2</span><span class="p">]</span>

        <span class="s s-Atom">indices</span> <span class="o">=</span> <span class="nf">add_head_tail</span><span class="p">(</span><span class="s s-Atom">metapath</span><span class="p">,</span> <span class="s s-Atom">indices</span><span class="p">)</span>

    <span class="s s-Atom">segments</span> <span class="o">=</span> <span class="p">[</span><span class="s s-Atom">metapath</span><span class="p">[</span><span class="s s-Atom">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="s s-Atom">:i</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="s s-Atom">for</span> <span class="s s-Atom">i</span> <span class="s s-Atom">in</span> <span class="s s-Atom">indices</span><span class="p">]</span>

    <span class="s s-Atom">segments</span> <span class="o">=</span> <span class="p">[</span><span class="s s-Atom">i</span> <span class="s s-Atom">for</span> <span class="s s-Atom">i</span> <span class="s s-Atom">in</span> <span class="s s-Atom">segments</span> <span class="s s-Atom">if</span> <span class="s s-Atom">i</span><span class="p">]</span>

    <span class="s s-Atom">segments</span> <span class="o">=</span> <span class="p">[</span><span class="s s-Atom">metagraph</span><span class="p">.</span><span class="nf">get_metapath</span><span class="p">(</span><span class="s s-Atom">metaedges</span><span class="p">)</span> <span class="s s-Atom">for</span> <span class="s s-Atom">metaedges</span> <span class="s s-Atom">in</span> <span class="s s-Atom">segments</span><span class="p">]</span>

    <span class="s s-Atom">#</span> <span class="nn">eg</span><span class="p">:</span> <span class="nv">B</span> <span class="nv">CC</span> <span class="nv">ABA</span>

    <span class="s s-Atom">if</span> <span class="s s-Atom">category</span> <span class="o">==</span> <span class="s s-Atom">&#39;interior_complete_group&#39;:</span>

        <span class="s s-Atom">segs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="s s-Atom">for</span> <span class="s s-Atom">i</span><span class="p">,</span> <span class="s s-Atom">v</span> <span class="s s-Atom">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="s s-Atom">segments</span><span class="p">[:-</span><span class="mi">1</span><span class="p">])</span><span class="s s-Atom">:</span>

            <span class="s s-Atom">if</span> <span class="s s-Atom">segments</span><span class="p">[</span><span class="s s-Atom">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="nf">source</span><span class="p">()</span> <span class="o">==</span> <span class="s s-Atom">segments</span><span class="p">[</span><span class="s s-Atom">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="nf">target</span><span class="p">()</span><span class="s s-Atom">:</span>

                <span class="s s-Atom">edges</span> <span class="o">=</span> <span class="s s-Atom">v</span><span class="p">.</span><span class="s s-Atom">edges</span> <span class="o">+</span> <span class="s s-Atom">segments</span><span class="p">[</span><span class="s s-Atom">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="s s-Atom">edges</span> <span class="o">+</span> <span class="s s-Atom">segments</span><span class="p">[</span><span class="s s-Atom">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">].</span><span class="s s-Atom">edges</span>

                <span class="s s-Atom">segs</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="s s-Atom">metagraph</span><span class="p">.</span><span class="nf">get_metapath</span><span class="p">(</span><span class="s s-Atom">edges</span><span class="p">))</span>

            <span class="s s-Atom">elif</span> <span class="s s-Atom">v</span><span class="p">.</span><span class="nf">source</span><span class="p">()</span> <span class="o">==</span> <span class="s s-Atom">v</span><span class="p">.</span><span class="nf">target</span><span class="p">()</span><span class="s s-Atom">:</span>

                <span class="s s-Atom">pass</span>

            <span class="s s-Atom">elif</span> <span class="s s-Atom">segments</span><span class="p">[</span><span class="s s-Atom">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="nf">source</span><span class="p">()</span> <span class="o">==</span> <span class="s s-Atom">segments</span><span class="p">[</span><span class="s s-Atom">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="nf">target</span><span class="p">()</span><span class="s s-Atom">:</span>

                <span class="s s-Atom">pass</span>

            <span class="nn">else</span><span class="p">:</span>

                <span class="s s-Atom">segs</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="s s-Atom">v</span><span class="p">)</span>

        <span class="s s-Atom">segs</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="s s-Atom">segments</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="s s-Atom">segments</span> <span class="o">=</span> <span class="s s-Atom">segs</span>

    <span class="s s-Atom">return</span> <span class="s s-Atom">segments</span>
</code></pre></div>


</details>
<h3 id="order_segments">order_segments</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">order_segments</span><span class="p">(</span>
    <span class="n">metagraph</span><span class="p">,</span>
    <span class="n">metapaths</span><span class="p">,</span>
    <span class="n">store_inverses</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>


<p>Gives the frequencies of metapath segments that occur when computing DWPC.
In DWPC computation, metapaths are split a number of times for simpler computation.
This function finds the frequencies that segments would be used when computing
DWPC for all given metapaths. For the targeted caching of the most frequently
used segments.</p>
<h2 id="parameters_6">Parameters</h2>
<p>metagraph : hetnetpy.hetnet.MetaGraph
metapaths : list
    list of hetnetpy.hetnet.MetaPath objects
store_inverses : bool
    Whether or not to include both forward and backward directions of segments.
    For example, if False: [CbG, GbC] -&gt; [CbG, CbG], else no change.</p>
<h2 id="returns_4">Returns</h2>
<p>collections.Counter
    Number of times each metapath segment appears when getting all segments.</p>
<details class="example"><summary>View Source</summary><div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">order_segments</span><span class="p">(</span><span class="n">metagraph</span><span class="p">,</span> <span class="n">metapaths</span><span class="p">,</span> <span class="n">store_inverses</span><span class="o">=</span><span class="k">False</span><span class="p">):</span>

    <span class="ss">&quot;&quot;&quot;</span>

<span class="ss">    Gives the frequencies of metapath segments that occur when computing DWPC.</span>

<span class="ss">    In DWPC computation, metapaths are split a number of times for simpler computation.</span>

<span class="ss">    This function finds the frequencies that segments would be used when computing</span>

<span class="ss">    DWPC for all given metapaths. For the targeted caching of the most frequently</span>

<span class="ss">    used segments.</span>

<span class="ss">    Parameters</span>

<span class="ss">    ----------</span>

<span class="ss">    metagraph : hetnetpy.hetnet.MetaGraph</span>

<span class="ss">    metapaths : list</span>

<span class="ss">        list of hetnetpy.hetnet.MetaPath objects</span>

<span class="ss">    store_inverses : bool</span>

<span class="ss">        Whether or not to include both forward and backward directions of segments.</span>

<span class="ss">        For example, if False: [CbG, GbC] -&gt; [CbG, CbG], else no change.</span>

<span class="ss">    Returns</span>

<span class="ss">    -------</span>

<span class="ss">    collections.Counter</span>

<span class="ss">        Number of times each metapath segment appears when getting all segments.</span>

<span class="ss">    &quot;&quot;&quot;</span>

    <span class="n">all_segments</span> <span class="o">=</span> <span class="p">[</span><span class="n">segment</span> <span class="k">for</span> <span class="n">metapath</span> <span class="k">in</span> <span class="n">metapaths</span> <span class="k">for</span> <span class="n">segment</span> <span class="k">in</span> <span class="n">get_all_segments</span><span class="p">(</span><span class="n">metagraph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">)]</span>

    <span class="k">if</span> <span class="k">not</span> <span class="n">store_inverses</span><span class="p">:</span>

        <span class="o">#</span> <span class="n">Change</span> <span class="k">all</span> <span class="n">instances</span> <span class="k">of</span> <span class="n">inverted</span> <span class="n">segments</span> <span class="k">to</span> <span class="n">the</span> <span class="n">same</span> <span class="n">direction</span><span class="p">,</span> <span class="k">using</span> <span class="n">a</span> <span class="k">first</span><span class="o">-</span><span class="n">seen</span> <span class="n">ordering</span>

        <span class="n">seen</span> <span class="o">=</span> <span class="k">set</span><span class="p">()</span>

        <span class="n">aligned_segments</span> <span class="o">=</span> <span class="n">list</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">segment</span> <span class="k">in</span> <span class="n">all_segments</span><span class="p">:</span>

            <span class="k">add</span> <span class="o">=</span> <span class="n">segment</span><span class="p">.</span><span class="n">inverse</span> <span class="k">if</span> <span class="n">segment</span><span class="p">.</span><span class="n">inverse</span> <span class="k">in</span> <span class="n">seen</span> <span class="k">else</span> <span class="n">segment</span>

            <span class="n">aligned_segments</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="k">add</span><span class="p">)</span>

            <span class="n">seen</span><span class="p">.</span><span class="k">add</span><span class="p">(</span><span class="k">add</span><span class="p">)</span>

        <span class="n">all_segments</span> <span class="o">=</span> <span class="n">aligned_segments</span>

    <span class="n">segment_counts</span> <span class="o">=</span> <span class="n">collections</span><span class="p">.</span><span class="n">Counter</span><span class="p">(</span><span class="n">all_segments</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">segment_counts</span>
</code></pre></div>


</details>
<h3 id="remove_diag">remove_diag</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">remove_diag</span><span class="p">(</span>
    <span class="n">mat</span><span class="p">,</span>
    <span class="n">dtype</span><span class="o">=&lt;</span><span class="k">class</span> <span class="err">&#39;</span><span class="nc">numpy</span><span class="o">.</span><span class="n">float64</span><span class="s1">&#39;&gt;</span>
<span class="p">)</span>
</code></pre></div>


<p>Set the main diagonal of a square matrix to zeros.</p>
<details class="example"><summary>View Source</summary><div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">remove_diag</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="p">.</span><span class="n">float64</span><span class="p">):</span>

    <span class="ss">&quot;&quot;&quot;Set the main diagonal of a square matrix to zeros.&quot;&quot;&quot;</span>

    <span class="n">assert</span> <span class="n">mat</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">mat</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="o">#</span> <span class="n">must</span> <span class="n">be</span> <span class="n">square</span>

    <span class="k">if</span> <span class="n">sparse</span><span class="p">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">mat</span><span class="p">):</span>

        <span class="k">return</span> <span class="n">mat</span> <span class="o">-</span> <span class="n">sparse</span><span class="p">.</span><span class="n">diags</span><span class="p">(</span><span class="n">mat</span><span class="p">.</span><span class="n">diagonal</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>

        <span class="k">return</span> <span class="n">mat</span> <span class="o">-</span> <span class="n">numpy</span><span class="p">.</span><span class="n">diag</span><span class="p">(</span><span class="n">mat</span><span class="p">.</span><span class="n">diagonal</span><span class="p">())</span>
</code></pre></div>


</details>
                
                  
                
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../degree_group/" title="Degree Group" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                Degree Group
              </span>
            </div>
          </a>
        
        
          <a href="../diffusion/" title="Diffusion" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                Diffusion
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Powered by
        <a href="http://timothycrosley.github.io/portray">portray.</a>
        You too can
        <a href="http://timothycrosley.github.io/portray">
          portray</a>
        your Python project well using automatic documentation.
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../../assets/javascripts/application.c33a9706.js"></script>
      
      <script>app.initialize({version:"1.1.2",url:{base:"../../.."}})</script>
      
    
  </body>
</html>